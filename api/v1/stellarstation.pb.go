// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: stellarstation/api/v1/stellarstation.proto

package stellarstation

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import timestamp "github.com/golang/protobuf/ptypes/timestamp"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// A type of framing of a binary payload used in satellite communicaation.
type Framing int32

const (
	// No framing done in the API. All payloads are assumed to be pre-framed and ready for
	// transmission to the satellite or API client with no additional processing.
	Framing_BITSTREAM Framing = 0
	// AX.25 (Amateur X.25) framing - https://en.wikipedia.org/wiki/AX.25
	Framing_AX25 Framing = 1
	// No framing or demodulation done in the API. Raw IQ data is sent to the API client with no
	// additional processing.
	Framing_IQ Framing = 2
)

var Framing_name = map[int32]string{
	0: "BITSTREAM",
	1: "AX25",
	2: "IQ",
}
var Framing_value = map[string]int32{
	"BITSTREAM": 0,
	"AX25":      1,
	"IQ":        2,
}

func (x Framing) String() string {
	return proto.EnumName(Framing_name, int32(x))
}
func (Framing) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_de750d0a12450e2d, []int{0}
}

// Status of a plan.
type Plan_Status int32

const (
	// The plan has been scheduled and will be executed at `aos_time`.
	Plan_RESERVED Plan_Status = 0
	// The plan is currently executing.
	Plan_EXECUTING Plan_Status = 1
	// The plan has executed successfully.
	Plan_SUCCEEDED Plan_Status = 2
	// The plan has executed but was not successful.
	Plan_FAILED Plan_Status = 3
	// The plan has been cancelled and will not be executed.
	Plan_CANCELLED Plan_Status = 4
)

var Plan_Status_name = map[int32]string{
	0: "RESERVED",
	1: "EXECUTING",
	2: "SUCCEEDED",
	3: "FAILED",
	4: "CANCELLED",
}
var Plan_Status_value = map[string]int32{
	"RESERVED":  0,
	"EXECUTING": 1,
	"SUCCEEDED": 2,
	"FAILED":    3,
	"CANCELLED": 4,
}

func (x Plan_Status) String() string {
	return proto.EnumName(Plan_Status_name, int32(x))
}
func (Plan_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_de750d0a12450e2d, []int{7, 0}
}

// Request for the `OpenSatelliteStream` method.
type SatelliteStreamRequest struct {
	// The ID of the satellite to open a stream with. The ID of a satellite can be found on the
	// StellarStation Console page for the satellite.
	SatelliteId string `protobuf:"bytes,1,opt,name=satellite_id,json=satelliteId,proto3" json:"satellite_id,omitempty"`
	// The `SatelliteStreamResponse.stream_id` from a previously opened stream to resume. If the
	// specified stream has already expired or been closed, the stream is closed with a `ABORTED`
	// error.
	StreamId string `protobuf:"bytes,2,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	// A request to send on the satellite stream. Currently only command sending to the satellite is
	// supported. The request does not need to be filled on the first request to
	// `OpenSatelliteStream`.
	//
	// Types that are valid to be assigned to Request:
	//	*SatelliteStreamRequest_SendSatelliteCommandsRequest
	Request              isSatelliteStreamRequest_Request `protobuf_oneof:"Request"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *SatelliteStreamRequest) Reset()         { *m = SatelliteStreamRequest{} }
func (m *SatelliteStreamRequest) String() string { return proto.CompactTextString(m) }
func (*SatelliteStreamRequest) ProtoMessage()    {}
func (*SatelliteStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_de750d0a12450e2d, []int{0}
}
func (m *SatelliteStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SatelliteStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SatelliteStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SatelliteStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SatelliteStreamRequest.Merge(dst, src)
}
func (m *SatelliteStreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *SatelliteStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SatelliteStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SatelliteStreamRequest proto.InternalMessageInfo

type isSatelliteStreamRequest_Request interface {
	isSatelliteStreamRequest_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SatelliteStreamRequest_SendSatelliteCommandsRequest struct {
	SendSatelliteCommandsRequest *SendSatelliteCommandsRequest `protobuf:"bytes,3,opt,name=send_satellite_commands_request,json=sendSatelliteCommandsRequest,oneof"`
}

func (*SatelliteStreamRequest_SendSatelliteCommandsRequest) isSatelliteStreamRequest_Request() {}

func (m *SatelliteStreamRequest) GetRequest() isSatelliteStreamRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *SatelliteStreamRequest) GetSatelliteId() string {
	if m != nil {
		return m.SatelliteId
	}
	return ""
}

func (m *SatelliteStreamRequest) GetStreamId() string {
	if m != nil {
		return m.StreamId
	}
	return ""
}

func (m *SatelliteStreamRequest) GetSendSatelliteCommandsRequest() *SendSatelliteCommandsRequest {
	if x, ok := m.GetRequest().(*SatelliteStreamRequest_SendSatelliteCommandsRequest); ok {
		return x.SendSatelliteCommandsRequest
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SatelliteStreamRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SatelliteStreamRequest_OneofMarshaler, _SatelliteStreamRequest_OneofUnmarshaler, _SatelliteStreamRequest_OneofSizer, []interface{}{
		(*SatelliteStreamRequest_SendSatelliteCommandsRequest)(nil),
	}
}

func _SatelliteStreamRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SatelliteStreamRequest)
	// Request
	switch x := m.Request.(type) {
	case *SatelliteStreamRequest_SendSatelliteCommandsRequest:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SendSatelliteCommandsRequest); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SatelliteStreamRequest.Request has unexpected type %T", x)
	}
	return nil
}

func _SatelliteStreamRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SatelliteStreamRequest)
	switch tag {
	case 3: // Request.send_satellite_commands_request
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SendSatelliteCommandsRequest)
		err := b.DecodeMessage(msg)
		m.Request = &SatelliteStreamRequest_SendSatelliteCommandsRequest{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SatelliteStreamRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SatelliteStreamRequest)
	// Request
	switch x := m.Request.(type) {
	case *SatelliteStreamRequest_SendSatelliteCommandsRequest:
		s := proto.Size(x.SendSatelliteCommandsRequest)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A request to send commands to a satellite.
type SendSatelliteCommandsRequest struct {
	// The framing to be applied to `command` before transmission. If `command` has already been
	// framed, this should be set to BITSTREAM and no additional processing will take place before
	// modulation. When applying framing, each `command` will be treated as a single frame. Framing
	// parameters used will be the ones registered for the satellite in the StellarStation Console.
	//
	// Currently IQ is not allowed for `output_framing`.
	OutputFraming Framing `protobuf:"varint,1,opt,name=output_framing,json=outputFraming,proto3,enum=stellarstation.api.v1.Framing" json:"output_framing,omitempty"`
	// The command frames to send to the satellite. All commands will be transmitted in sequence
	// immediately, during which time telemetry will not be received. After all commands have been
	// transmitted, telemetry receive will be immediately re-enabled. Them aximum size of each command
	// is 2MB. If a command larger than 2MB is received, the stream will be closed with a
	// `RESOURCE_EXHAUSTED` error.
	Command              [][]byte `protobuf:"bytes,2,rep,name=command" json:"command,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SendSatelliteCommandsRequest) Reset()         { *m = SendSatelliteCommandsRequest{} }
func (m *SendSatelliteCommandsRequest) String() string { return proto.CompactTextString(m) }
func (*SendSatelliteCommandsRequest) ProtoMessage()    {}
func (*SendSatelliteCommandsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_de750d0a12450e2d, []int{1}
}
func (m *SendSatelliteCommandsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendSatelliteCommandsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendSatelliteCommandsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SendSatelliteCommandsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendSatelliteCommandsRequest.Merge(dst, src)
}
func (m *SendSatelliteCommandsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SendSatelliteCommandsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SendSatelliteCommandsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SendSatelliteCommandsRequest proto.InternalMessageInfo

func (m *SendSatelliteCommandsRequest) GetOutputFraming() Framing {
	if m != nil {
		return m.OutputFraming
	}
	return Framing_BITSTREAM
}

func (m *SendSatelliteCommandsRequest) GetCommand() [][]byte {
	if m != nil {
		return m.Command
	}
	return nil
}

// A response from the `OpenSatelliteStream` method.
type SatelliteStreamResponse struct {
	// The ID of this stream, which can be used in a subsequent call to `OpenSatelliteStream` to
	// resume this stream on interruption (e.g., if a network failure causes the connection to be
	// closed mid-stream). Telemetry received on a previously opened stream with no current listener
	// will be buffered for a maximum of 1 minute, and the stream itself will be cancelled and no more
	// buffering will occur if no client resumes the stream with `OpenSatelliteStream` within 10
	// minutes.
	StreamId string `protobuf:"bytes,1,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	// A response on the stream. Currently the only type of response is telemetry received from the
	// satellite.
	//
	// Types that are valid to be assigned to Response:
	//	*SatelliteStreamResponse_ReceiveTelemetryResponse
	Response             isSatelliteStreamResponse_Response `protobuf_oneof:"Response"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *SatelliteStreamResponse) Reset()         { *m = SatelliteStreamResponse{} }
func (m *SatelliteStreamResponse) String() string { return proto.CompactTextString(m) }
func (*SatelliteStreamResponse) ProtoMessage()    {}
func (*SatelliteStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_de750d0a12450e2d, []int{2}
}
func (m *SatelliteStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SatelliteStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SatelliteStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SatelliteStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SatelliteStreamResponse.Merge(dst, src)
}
func (m *SatelliteStreamResponse) XXX_Size() int {
	return m.Size()
}
func (m *SatelliteStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SatelliteStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SatelliteStreamResponse proto.InternalMessageInfo

type isSatelliteStreamResponse_Response interface {
	isSatelliteStreamResponse_Response()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SatelliteStreamResponse_ReceiveTelemetryResponse struct {
	ReceiveTelemetryResponse *ReceiveTelemetryResponse `protobuf:"bytes,2,opt,name=receive_telemetry_response,json=receiveTelemetryResponse,oneof"`
}

func (*SatelliteStreamResponse_ReceiveTelemetryResponse) isSatelliteStreamResponse_Response() {}

func (m *SatelliteStreamResponse) GetResponse() isSatelliteStreamResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *SatelliteStreamResponse) GetStreamId() string {
	if m != nil {
		return m.StreamId
	}
	return ""
}

func (m *SatelliteStreamResponse) GetReceiveTelemetryResponse() *ReceiveTelemetryResponse {
	if x, ok := m.GetResponse().(*SatelliteStreamResponse_ReceiveTelemetryResponse); ok {
		return x.ReceiveTelemetryResponse
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SatelliteStreamResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SatelliteStreamResponse_OneofMarshaler, _SatelliteStreamResponse_OneofUnmarshaler, _SatelliteStreamResponse_OneofSizer, []interface{}{
		(*SatelliteStreamResponse_ReceiveTelemetryResponse)(nil),
	}
}

func _SatelliteStreamResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SatelliteStreamResponse)
	// Response
	switch x := m.Response.(type) {
	case *SatelliteStreamResponse_ReceiveTelemetryResponse:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ReceiveTelemetryResponse); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SatelliteStreamResponse.Response has unexpected type %T", x)
	}
	return nil
}

func _SatelliteStreamResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SatelliteStreamResponse)
	switch tag {
	case 2: // Response.receive_telemetry_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ReceiveTelemetryResponse)
		err := b.DecodeMessage(msg)
		m.Response = &SatelliteStreamResponse_ReceiveTelemetryResponse{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SatelliteStreamResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SatelliteStreamResponse)
	// Response
	switch x := m.Response.(type) {
	case *SatelliteStreamResponse_ReceiveTelemetryResponse:
		s := proto.Size(x.ReceiveTelemetryResponse)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A response from a satellite containing telemetry.
type ReceiveTelemetryResponse struct {
	// The telemetry received.
	Telemetry            *Telemetry `protobuf:"bytes,1,opt,name=telemetry" json:"telemetry,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ReceiveTelemetryResponse) Reset()         { *m = ReceiveTelemetryResponse{} }
func (m *ReceiveTelemetryResponse) String() string { return proto.CompactTextString(m) }
func (*ReceiveTelemetryResponse) ProtoMessage()    {}
func (*ReceiveTelemetryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_de750d0a12450e2d, []int{3}
}
func (m *ReceiveTelemetryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReceiveTelemetryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReceiveTelemetryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ReceiveTelemetryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiveTelemetryResponse.Merge(dst, src)
}
func (m *ReceiveTelemetryResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReceiveTelemetryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiveTelemetryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiveTelemetryResponse proto.InternalMessageInfo

func (m *ReceiveTelemetryResponse) GetTelemetry() *Telemetry {
	if m != nil {
		return m.Telemetry
	}
	return nil
}

// A chunk or frame of telemetry data that has been received from a satellite.
type Telemetry struct {
	// The framing of this telemetry data. If `RAW`, this telemetry will be an arbitrarily sized
	// chunk of the bitstream.
	Framing Framing `protobuf:"varint,1,opt,name=framing,proto3,enum=stellarstation.api.v1.Framing" json:"framing,omitempty"`
	// The payload of this telemetry.
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	// The actual downlink frequency, in Hz, used when receiving `data`, including adjustments for
	// doppler shift.
	DownlinkFrequencyHz uint64 `protobuf:"varint,3,opt,name=downlink_frequency_hz,json=downlinkFrequencyHz,proto3" json:"downlink_frequency_hz,omitempty"`
	// Timestamp when the first byte of `data` was received.
	TimeFirstByteReceived *timestamp.Timestamp `protobuf:"bytes,4,opt,name=time_first_byte_received,json=timeFirstByteReceived" json:"time_first_byte_received,omitempty"`
	// Timestamp when the last byte of `data` was received.
	TimeLastByteReceived *timestamp.Timestamp `protobuf:"bytes,5,opt,name=time_last_byte_received,json=timeLastByteReceived" json:"time_last_byte_received,omitempty"`
	// The binary header of the telemetry frame, if `framing` is not `RAW`.
	//
	// * AX25 - This is either Address + Control, or Address + Control + PID. The checksum is not
	//          returned.
	FrameHeader          []byte   `protobuf:"bytes,6,opt,name=frame_header,json=frameHeader,proto3" json:"frame_header,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Telemetry) Reset()         { *m = Telemetry{} }
func (m *Telemetry) String() string { return proto.CompactTextString(m) }
func (*Telemetry) ProtoMessage()    {}
func (*Telemetry) Descriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_de750d0a12450e2d, []int{4}
}
func (m *Telemetry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Telemetry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Telemetry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Telemetry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Telemetry.Merge(dst, src)
}
func (m *Telemetry) XXX_Size() int {
	return m.Size()
}
func (m *Telemetry) XXX_DiscardUnknown() {
	xxx_messageInfo_Telemetry.DiscardUnknown(m)
}

var xxx_messageInfo_Telemetry proto.InternalMessageInfo

func (m *Telemetry) GetFraming() Framing {
	if m != nil {
		return m.Framing
	}
	return Framing_BITSTREAM
}

func (m *Telemetry) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Telemetry) GetDownlinkFrequencyHz() uint64 {
	if m != nil {
		return m.DownlinkFrequencyHz
	}
	return 0
}

func (m *Telemetry) GetTimeFirstByteReceived() *timestamp.Timestamp {
	if m != nil {
		return m.TimeFirstByteReceived
	}
	return nil
}

func (m *Telemetry) GetTimeLastByteReceived() *timestamp.Timestamp {
	if m != nil {
		return m.TimeLastByteReceived
	}
	return nil
}

func (m *Telemetry) GetFrameHeader() []byte {
	if m != nil {
		return m.FrameHeader
	}
	return nil
}

// Request for the `ListGroundstationPlans` method.
type ListGroundStationPlansRequest struct {
	// The ID of the ground station to list plans for. The ID can be found on the StellarStation
	// Console page for the ground station.
	GroundStationId string `protobuf:"bytes,1,opt,name=ground_station_id,json=groundStationId,proto3" json:"ground_station_id,omitempty"`
	// The start time of the range of plans to list (inclusive). Only plans with an Acquisition of
	// Signal (AOS) at or after this time will be returned. It is an error for the duration between
	// `aos_after` and `aos_before` to be longer than 31 days.
	AosAfter *timestamp.Timestamp `protobuf:"bytes,2,opt,name=aos_after,json=aosAfter" json:"aos_after,omitempty"`
	// The end time of the range of plans to list (exclusive). Only plans with an Acquisition of
	// Signal (AOS) before this time will be returned. It is an error for the duration between
	// `aos_after` and `aos_before` to be longer than 31 days.
	AosBefore            *timestamp.Timestamp `protobuf:"bytes,3,opt,name=aos_before,json=aosBefore" json:"aos_before,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ListGroundStationPlansRequest) Reset()         { *m = ListGroundStationPlansRequest{} }
func (m *ListGroundStationPlansRequest) String() string { return proto.CompactTextString(m) }
func (*ListGroundStationPlansRequest) ProtoMessage()    {}
func (*ListGroundStationPlansRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_de750d0a12450e2d, []int{5}
}
func (m *ListGroundStationPlansRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListGroundStationPlansRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListGroundStationPlansRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListGroundStationPlansRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListGroundStationPlansRequest.Merge(dst, src)
}
func (m *ListGroundStationPlansRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListGroundStationPlansRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListGroundStationPlansRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListGroundStationPlansRequest proto.InternalMessageInfo

func (m *ListGroundStationPlansRequest) GetGroundStationId() string {
	if m != nil {
		return m.GroundStationId
	}
	return ""
}

func (m *ListGroundStationPlansRequest) GetAosAfter() *timestamp.Timestamp {
	if m != nil {
		return m.AosAfter
	}
	return nil
}

func (m *ListGroundStationPlansRequest) GetAosBefore() *timestamp.Timestamp {
	if m != nil {
		return m.AosBefore
	}
	return nil
}

// A response from the `ListGroundstationPlans` method.
type ListGroundStationPlansResponse struct {
	// The requested list of plans for the ground station.
	Plan                 []*Plan  `protobuf:"bytes,1,rep,name=plan" json:"plan,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListGroundStationPlansResponse) Reset()         { *m = ListGroundStationPlansResponse{} }
func (m *ListGroundStationPlansResponse) String() string { return proto.CompactTextString(m) }
func (*ListGroundStationPlansResponse) ProtoMessage()    {}
func (*ListGroundStationPlansResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_de750d0a12450e2d, []int{6}
}
func (m *ListGroundStationPlansResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListGroundStationPlansResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListGroundStationPlansResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListGroundStationPlansResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListGroundStationPlansResponse.Merge(dst, src)
}
func (m *ListGroundStationPlansResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListGroundStationPlansResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListGroundStationPlansResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListGroundStationPlansResponse proto.InternalMessageInfo

func (m *ListGroundStationPlansResponse) GetPlan() []*Plan {
	if m != nil {
		return m.Plan
	}
	return nil
}

// A scheduled pass. The plan will be executed on its ground station to communicate with its satellite
// during a time range between AOS and LOS, unless explicitly cancelled.
type Plan struct {
	// The ID of this plan.
	PlanId string `protobuf:"bytes,1,opt,name=plan_id,json=planId,proto3" json:"plan_id,omitempty"`
	// The status of this plan.
	Status Plan_Status `protobuf:"varint,2,opt,name=status,proto3,enum=stellarstation.api.v1.Plan_Status" json:"status,omitempty"`
	// The TLE used to compute this plan. Always has exactly two items corresponding to line 1 and
	// line 2 of the 2-line TLE format.
	//
	// https://en.wikipedia.org/wiki/Two-line_element_set
	TleLine []string `protobuf:"bytes,3,rep,name=tle_line,json=tleLine" json:"tle_line,omitempty"`
	// The time of AOS between the ground station and satellite in this plan.
	AosTime *timestamp.Timestamp `protobuf:"bytes,4,opt,name=aos_time,json=aosTime" json:"aos_time,omitempty"`
	// The time of LOS between the ground station and satellite in this plan.
	LosTime *timestamp.Timestamp `protobuf:"bytes,5,opt,name=los_time,json=losTime" json:"los_time,omitempty"`
	// The center frequency, in Hz, for downlinking in this plan. 0 if downlink is not available in
	// this plan.
	DownlinkCenterFrequencyHz uint64 `protobuf:"varint,6,opt,name=downlink_center_frequency_hz,json=downlinkCenterFrequencyHz,proto3" json:"downlink_center_frequency_hz,omitempty"`
	// The center frequency, in Hz, for uplinking in this plan. 0 if uplink is not available in this
	// plan.
	UplinkCenterFrequencyHz uint64 `protobuf:"varint,7,opt,name=uplink_center_frequency_hz,json=uplinkCenterFrequencyHz,proto3" json:"uplink_center_frequency_hz,omitempty"`
	// The max elevation of the plan, in degrees.
	MaxElevationDegrees float64 `protobuf:"fixed64,8,opt,name=max_elevation_degrees,json=maxElevationDegrees,proto3" json:"max_elevation_degrees,omitempty"`
	// The time of max elevation during the plan.
	MaxElevationTime     *timestamp.Timestamp `protobuf:"bytes,9,opt,name=max_elevation_time,json=maxElevationTime" json:"max_elevation_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Plan) Reset()         { *m = Plan{} }
func (m *Plan) String() string { return proto.CompactTextString(m) }
func (*Plan) ProtoMessage()    {}
func (*Plan) Descriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_de750d0a12450e2d, []int{7}
}
func (m *Plan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Plan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Plan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Plan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Plan.Merge(dst, src)
}
func (m *Plan) XXX_Size() int {
	return m.Size()
}
func (m *Plan) XXX_DiscardUnknown() {
	xxx_messageInfo_Plan.DiscardUnknown(m)
}

var xxx_messageInfo_Plan proto.InternalMessageInfo

func (m *Plan) GetPlanId() string {
	if m != nil {
		return m.PlanId
	}
	return ""
}

func (m *Plan) GetStatus() Plan_Status {
	if m != nil {
		return m.Status
	}
	return Plan_RESERVED
}

func (m *Plan) GetTleLine() []string {
	if m != nil {
		return m.TleLine
	}
	return nil
}

func (m *Plan) GetAosTime() *timestamp.Timestamp {
	if m != nil {
		return m.AosTime
	}
	return nil
}

func (m *Plan) GetLosTime() *timestamp.Timestamp {
	if m != nil {
		return m.LosTime
	}
	return nil
}

func (m *Plan) GetDownlinkCenterFrequencyHz() uint64 {
	if m != nil {
		return m.DownlinkCenterFrequencyHz
	}
	return 0
}

func (m *Plan) GetUplinkCenterFrequencyHz() uint64 {
	if m != nil {
		return m.UplinkCenterFrequencyHz
	}
	return 0
}

func (m *Plan) GetMaxElevationDegrees() float64 {
	if m != nil {
		return m.MaxElevationDegrees
	}
	return 0
}

func (m *Plan) GetMaxElevationTime() *timestamp.Timestamp {
	if m != nil {
		return m.MaxElevationTime
	}
	return nil
}

func init() {
	proto.RegisterType((*SatelliteStreamRequest)(nil), "stellarstation.api.v1.SatelliteStreamRequest")
	proto.RegisterType((*SendSatelliteCommandsRequest)(nil), "stellarstation.api.v1.SendSatelliteCommandsRequest")
	proto.RegisterType((*SatelliteStreamResponse)(nil), "stellarstation.api.v1.SatelliteStreamResponse")
	proto.RegisterType((*ReceiveTelemetryResponse)(nil), "stellarstation.api.v1.ReceiveTelemetryResponse")
	proto.RegisterType((*Telemetry)(nil), "stellarstation.api.v1.Telemetry")
	proto.RegisterType((*ListGroundStationPlansRequest)(nil), "stellarstation.api.v1.ListGroundStationPlansRequest")
	proto.RegisterType((*ListGroundStationPlansResponse)(nil), "stellarstation.api.v1.ListGroundStationPlansResponse")
	proto.RegisterType((*Plan)(nil), "stellarstation.api.v1.Plan")
	proto.RegisterEnum("stellarstation.api.v1.Framing", Framing_name, Framing_value)
	proto.RegisterEnum("stellarstation.api.v1.Plan_Status", Plan_Status_name, Plan_Status_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for StellarStationService service

type StellarStationServiceClient interface {
	// Lists the plans for a particular ground station.
	//
	// The request will be closed with an `INVALID_ARGUMENT` status if `ground_station_id`,
	// `aos_after`, or `aos_before` are missing, or the duration between the two times is longer than
	// 31 days.
	ListGroundStationPlans(ctx context.Context, in *ListGroundStationPlansRequest, opts ...grpc.CallOption) (*ListGroundStationPlansResponse, error)
	// Open a stream to a satellite. The returned stream is bi-directional - it can be used by the
	// client to send commands to the satellite and data received from the satellite will be returned
	// as it is made available. All telemetry received from the satellite on reserved passes from this
	// point on will be returned as soon as this method is called. If
	// `SatelliteStreamRequest.stream_id` is specified, any messages that have been buffered for the
	// stream will be returned as well.
	//
	// The stream can be left open for any amount of time and telemetry will be received as available
	// and returned. When the client is done with the stream, it should close it successfully. If the
	// stream is cancelled with an unexpected error at any point, telemetry received before the next
	// call to `OpenSatelliteStream` to resume the stream will be buffered up to 1 minute, and if no
	// call to `OpenSatelliteStream` is made with `stream_id` specified to resume the stream, it will
	// expire in 10 minutes and a call to `OpenSatelliteStream` with that `stream_id` will be closed
	// with a `ABORTED` error.
	//
	// If the satellite is not found or the client is not authorized for it, the stream will be closed
	// with a `NOT_FOUND` error.
	OpenSatelliteStream(ctx context.Context, opts ...grpc.CallOption) (StellarStationService_OpenSatelliteStreamClient, error)
}

type stellarStationServiceClient struct {
	cc *grpc.ClientConn
}

func NewStellarStationServiceClient(cc *grpc.ClientConn) StellarStationServiceClient {
	return &stellarStationServiceClient{cc}
}

func (c *stellarStationServiceClient) ListGroundStationPlans(ctx context.Context, in *ListGroundStationPlansRequest, opts ...grpc.CallOption) (*ListGroundStationPlansResponse, error) {
	out := new(ListGroundStationPlansResponse)
	err := c.cc.Invoke(ctx, "/stellarstation.api.v1.StellarStationService/ListGroundStationPlans", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stellarStationServiceClient) OpenSatelliteStream(ctx context.Context, opts ...grpc.CallOption) (StellarStationService_OpenSatelliteStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StellarStationService_serviceDesc.Streams[0], "/stellarstation.api.v1.StellarStationService/OpenSatelliteStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &stellarStationServiceOpenSatelliteStreamClient{stream}
	return x, nil
}

type StellarStationService_OpenSatelliteStreamClient interface {
	Send(*SatelliteStreamRequest) error
	Recv() (*SatelliteStreamResponse, error)
	grpc.ClientStream
}

type stellarStationServiceOpenSatelliteStreamClient struct {
	grpc.ClientStream
}

func (x *stellarStationServiceOpenSatelliteStreamClient) Send(m *SatelliteStreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *stellarStationServiceOpenSatelliteStreamClient) Recv() (*SatelliteStreamResponse, error) {
	m := new(SatelliteStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for StellarStationService service

type StellarStationServiceServer interface {
	// Lists the plans for a particular ground station.
	//
	// The request will be closed with an `INVALID_ARGUMENT` status if `ground_station_id`,
	// `aos_after`, or `aos_before` are missing, or the duration between the two times is longer than
	// 31 days.
	ListGroundStationPlans(context.Context, *ListGroundStationPlansRequest) (*ListGroundStationPlansResponse, error)
	// Open a stream to a satellite. The returned stream is bi-directional - it can be used by the
	// client to send commands to the satellite and data received from the satellite will be returned
	// as it is made available. All telemetry received from the satellite on reserved passes from this
	// point on will be returned as soon as this method is called. If
	// `SatelliteStreamRequest.stream_id` is specified, any messages that have been buffered for the
	// stream will be returned as well.
	//
	// The stream can be left open for any amount of time and telemetry will be received as available
	// and returned. When the client is done with the stream, it should close it successfully. If the
	// stream is cancelled with an unexpected error at any point, telemetry received before the next
	// call to `OpenSatelliteStream` to resume the stream will be buffered up to 1 minute, and if no
	// call to `OpenSatelliteStream` is made with `stream_id` specified to resume the stream, it will
	// expire in 10 minutes and a call to `OpenSatelliteStream` with that `stream_id` will be closed
	// with a `ABORTED` error.
	//
	// If the satellite is not found or the client is not authorized for it, the stream will be closed
	// with a `NOT_FOUND` error.
	OpenSatelliteStream(StellarStationService_OpenSatelliteStreamServer) error
}

func RegisterStellarStationServiceServer(s *grpc.Server, srv StellarStationServiceServer) {
	s.RegisterService(&_StellarStationService_serviceDesc, srv)
}

func _StellarStationService_ListGroundStationPlans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGroundStationPlansRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StellarStationServiceServer).ListGroundStationPlans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stellarstation.api.v1.StellarStationService/ListGroundStationPlans",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StellarStationServiceServer).ListGroundStationPlans(ctx, req.(*ListGroundStationPlansRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StellarStationService_OpenSatelliteStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StellarStationServiceServer).OpenSatelliteStream(&stellarStationServiceOpenSatelliteStreamServer{stream})
}

type StellarStationService_OpenSatelliteStreamServer interface {
	Send(*SatelliteStreamResponse) error
	Recv() (*SatelliteStreamRequest, error)
	grpc.ServerStream
}

type stellarStationServiceOpenSatelliteStreamServer struct {
	grpc.ServerStream
}

func (x *stellarStationServiceOpenSatelliteStreamServer) Send(m *SatelliteStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *stellarStationServiceOpenSatelliteStreamServer) Recv() (*SatelliteStreamRequest, error) {
	m := new(SatelliteStreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _StellarStationService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "stellarstation.api.v1.StellarStationService",
	HandlerType: (*StellarStationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListGroundStationPlans",
			Handler:    _StellarStationService_ListGroundStationPlans_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "OpenSatelliteStream",
			Handler:       _StellarStationService_OpenSatelliteStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "stellarstation/api/v1/stellarstation.proto",
}

func (m *SatelliteStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SatelliteStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SatelliteId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(len(m.SatelliteId)))
		i += copy(dAtA[i:], m.SatelliteId)
	}
	if len(m.StreamId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(len(m.StreamId)))
		i += copy(dAtA[i:], m.StreamId)
	}
	if m.Request != nil {
		nn1, err := m.Request.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SatelliteStreamRequest_SendSatelliteCommandsRequest) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SendSatelliteCommandsRequest != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(m.SendSatelliteCommandsRequest.Size()))
		n2, err := m.SendSatelliteCommandsRequest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *SendSatelliteCommandsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendSatelliteCommandsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OutputFraming != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(m.OutputFraming))
	}
	if len(m.Command) > 0 {
		for _, b := range m.Command {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStellarstation(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SatelliteStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SatelliteStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StreamId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(len(m.StreamId)))
		i += copy(dAtA[i:], m.StreamId)
	}
	if m.Response != nil {
		nn3, err := m.Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SatelliteStreamResponse_ReceiveTelemetryResponse) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ReceiveTelemetryResponse != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(m.ReceiveTelemetryResponse.Size()))
		n4, err := m.ReceiveTelemetryResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *ReceiveTelemetryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReceiveTelemetryResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Telemetry != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(m.Telemetry.Size()))
		n5, err := m.Telemetry.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Telemetry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Telemetry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Framing != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(m.Framing))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.DownlinkFrequencyHz != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(m.DownlinkFrequencyHz))
	}
	if m.TimeFirstByteReceived != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(m.TimeFirstByteReceived.Size()))
		n6, err := m.TimeFirstByteReceived.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.TimeLastByteReceived != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(m.TimeLastByteReceived.Size()))
		n7, err := m.TimeLastByteReceived.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.FrameHeader) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(len(m.FrameHeader)))
		i += copy(dAtA[i:], m.FrameHeader)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListGroundStationPlansRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListGroundStationPlansRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GroundStationId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(len(m.GroundStationId)))
		i += copy(dAtA[i:], m.GroundStationId)
	}
	if m.AosAfter != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(m.AosAfter.Size()))
		n8, err := m.AosAfter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.AosBefore != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(m.AosBefore.Size()))
		n9, err := m.AosBefore.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListGroundStationPlansResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListGroundStationPlansResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Plan) > 0 {
		for _, msg := range m.Plan {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStellarstation(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Plan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Plan) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PlanId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(len(m.PlanId)))
		i += copy(dAtA[i:], m.PlanId)
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(m.Status))
	}
	if len(m.TleLine) > 0 {
		for _, s := range m.TleLine {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.AosTime != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(m.AosTime.Size()))
		n10, err := m.AosTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.LosTime != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(m.LosTime.Size()))
		n11, err := m.LosTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.DownlinkCenterFrequencyHz != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(m.DownlinkCenterFrequencyHz))
	}
	if m.UplinkCenterFrequencyHz != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(m.UplinkCenterFrequencyHz))
	}
	if m.MaxElevationDegrees != 0 {
		dAtA[i] = 0x41
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MaxElevationDegrees))))
		i += 8
	}
	if m.MaxElevationTime != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintStellarstation(dAtA, i, uint64(m.MaxElevationTime.Size()))
		n12, err := m.MaxElevationTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintStellarstation(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SatelliteStreamRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.SatelliteId)
	if l > 0 {
		n += 1 + l + sovStellarstation(uint64(l))
	}
	l = len(m.StreamId)
	if l > 0 {
		n += 1 + l + sovStellarstation(uint64(l))
	}
	if m.Request != nil {
		n += m.Request.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SatelliteStreamRequest_SendSatelliteCommandsRequest) Size() (n int) {
	var l int
	_ = l
	if m.SendSatelliteCommandsRequest != nil {
		l = m.SendSatelliteCommandsRequest.Size()
		n += 1 + l + sovStellarstation(uint64(l))
	}
	return n
}
func (m *SendSatelliteCommandsRequest) Size() (n int) {
	var l int
	_ = l
	if m.OutputFraming != 0 {
		n += 1 + sovStellarstation(uint64(m.OutputFraming))
	}
	if len(m.Command) > 0 {
		for _, b := range m.Command {
			l = len(b)
			n += 1 + l + sovStellarstation(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SatelliteStreamResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.StreamId)
	if l > 0 {
		n += 1 + l + sovStellarstation(uint64(l))
	}
	if m.Response != nil {
		n += m.Response.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SatelliteStreamResponse_ReceiveTelemetryResponse) Size() (n int) {
	var l int
	_ = l
	if m.ReceiveTelemetryResponse != nil {
		l = m.ReceiveTelemetryResponse.Size()
		n += 1 + l + sovStellarstation(uint64(l))
	}
	return n
}
func (m *ReceiveTelemetryResponse) Size() (n int) {
	var l int
	_ = l
	if m.Telemetry != nil {
		l = m.Telemetry.Size()
		n += 1 + l + sovStellarstation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Telemetry) Size() (n int) {
	var l int
	_ = l
	if m.Framing != 0 {
		n += 1 + sovStellarstation(uint64(m.Framing))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovStellarstation(uint64(l))
	}
	if m.DownlinkFrequencyHz != 0 {
		n += 1 + sovStellarstation(uint64(m.DownlinkFrequencyHz))
	}
	if m.TimeFirstByteReceived != nil {
		l = m.TimeFirstByteReceived.Size()
		n += 1 + l + sovStellarstation(uint64(l))
	}
	if m.TimeLastByteReceived != nil {
		l = m.TimeLastByteReceived.Size()
		n += 1 + l + sovStellarstation(uint64(l))
	}
	l = len(m.FrameHeader)
	if l > 0 {
		n += 1 + l + sovStellarstation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListGroundStationPlansRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.GroundStationId)
	if l > 0 {
		n += 1 + l + sovStellarstation(uint64(l))
	}
	if m.AosAfter != nil {
		l = m.AosAfter.Size()
		n += 1 + l + sovStellarstation(uint64(l))
	}
	if m.AosBefore != nil {
		l = m.AosBefore.Size()
		n += 1 + l + sovStellarstation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListGroundStationPlansResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Plan) > 0 {
		for _, e := range m.Plan {
			l = e.Size()
			n += 1 + l + sovStellarstation(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Plan) Size() (n int) {
	var l int
	_ = l
	l = len(m.PlanId)
	if l > 0 {
		n += 1 + l + sovStellarstation(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovStellarstation(uint64(m.Status))
	}
	if len(m.TleLine) > 0 {
		for _, s := range m.TleLine {
			l = len(s)
			n += 1 + l + sovStellarstation(uint64(l))
		}
	}
	if m.AosTime != nil {
		l = m.AosTime.Size()
		n += 1 + l + sovStellarstation(uint64(l))
	}
	if m.LosTime != nil {
		l = m.LosTime.Size()
		n += 1 + l + sovStellarstation(uint64(l))
	}
	if m.DownlinkCenterFrequencyHz != 0 {
		n += 1 + sovStellarstation(uint64(m.DownlinkCenterFrequencyHz))
	}
	if m.UplinkCenterFrequencyHz != 0 {
		n += 1 + sovStellarstation(uint64(m.UplinkCenterFrequencyHz))
	}
	if m.MaxElevationDegrees != 0 {
		n += 9
	}
	if m.MaxElevationTime != nil {
		l = m.MaxElevationTime.Size()
		n += 1 + l + sovStellarstation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovStellarstation(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStellarstation(x uint64) (n int) {
	return sovStellarstation(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SatelliteStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStellarstation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SatelliteStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SatelliteStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SatelliteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStellarstation
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SatelliteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStellarstation
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendSatelliteCommandsRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStellarstation
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SendSatelliteCommandsRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &SatelliteStreamRequest_SendSatelliteCommandsRequest{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStellarstation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStellarstation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendSatelliteCommandsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStellarstation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendSatelliteCommandsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendSatelliteCommandsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputFraming", wireType)
			}
			m.OutputFraming = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputFraming |= (Framing(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStellarstation
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, make([]byte, postIndex-iNdEx))
			copy(m.Command[len(m.Command)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStellarstation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStellarstation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SatelliteStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStellarstation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SatelliteStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SatelliteStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStellarstation
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiveTelemetryResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStellarstation
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReceiveTelemetryResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &SatelliteStreamResponse_ReceiveTelemetryResponse{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStellarstation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStellarstation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceiveTelemetryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStellarstation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReceiveTelemetryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReceiveTelemetryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Telemetry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStellarstation
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Telemetry == nil {
				m.Telemetry = &Telemetry{}
			}
			if err := m.Telemetry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStellarstation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStellarstation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Telemetry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStellarstation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Telemetry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Telemetry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Framing", wireType)
			}
			m.Framing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Framing |= (Framing(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStellarstation
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownlinkFrequencyHz", wireType)
			}
			m.DownlinkFrequencyHz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownlinkFrequencyHz |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeFirstByteReceived", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStellarstation
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeFirstByteReceived == nil {
				m.TimeFirstByteReceived = &timestamp.Timestamp{}
			}
			if err := m.TimeFirstByteReceived.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeLastByteReceived", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStellarstation
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeLastByteReceived == nil {
				m.TimeLastByteReceived = &timestamp.Timestamp{}
			}
			if err := m.TimeLastByteReceived.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameHeader", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStellarstation
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FrameHeader = append(m.FrameHeader[:0], dAtA[iNdEx:postIndex]...)
			if m.FrameHeader == nil {
				m.FrameHeader = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStellarstation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStellarstation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListGroundStationPlansRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStellarstation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListGroundStationPlansRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListGroundStationPlansRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroundStationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStellarstation
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroundStationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AosAfter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStellarstation
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AosAfter == nil {
				m.AosAfter = &timestamp.Timestamp{}
			}
			if err := m.AosAfter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AosBefore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStellarstation
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AosBefore == nil {
				m.AosBefore = &timestamp.Timestamp{}
			}
			if err := m.AosBefore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStellarstation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStellarstation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListGroundStationPlansResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStellarstation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListGroundStationPlansResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListGroundStationPlansResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStellarstation
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plan = append(m.Plan, &Plan{})
			if err := m.Plan[len(m.Plan)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStellarstation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStellarstation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Plan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStellarstation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Plan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Plan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStellarstation
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlanId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Plan_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TleLine", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStellarstation
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TleLine = append(m.TleLine, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AosTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStellarstation
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AosTime == nil {
				m.AosTime = &timestamp.Timestamp{}
			}
			if err := m.AosTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LosTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStellarstation
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LosTime == nil {
				m.LosTime = &timestamp.Timestamp{}
			}
			if err := m.LosTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownlinkCenterFrequencyHz", wireType)
			}
			m.DownlinkCenterFrequencyHz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownlinkCenterFrequencyHz |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkCenterFrequencyHz", wireType)
			}
			m.UplinkCenterFrequencyHz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkCenterFrequencyHz |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxElevationDegrees", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MaxElevationDegrees = float64(math.Float64frombits(v))
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxElevationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStellarstation
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxElevationTime == nil {
				m.MaxElevationTime = &timestamp.Timestamp{}
			}
			if err := m.MaxElevationTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStellarstation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStellarstation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStellarstation(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStellarstation
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStellarstation
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStellarstation
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStellarstation
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStellarstation(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStellarstation = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStellarstation   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("stellarstation/api/v1/stellarstation.proto", fileDescriptor_stellarstation_de750d0a12450e2d)
}

var fileDescriptor_stellarstation_de750d0a12450e2d = []byte{
	// 974 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x96, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0xc7, 0xbd, 0xb2, 0x2a, 0x89, 0x23, 0xdb, 0x55, 0xd7, 0x55, 0x4c, 0x2b, 0xae, 0xa2, 0xf0,
	0x24, 0x18, 0xa8, 0xd4, 0x30, 0x35, 0xfa, 0x05, 0xb4, 0xd0, 0x07, 0x1d, 0x09, 0x50, 0x13, 0x9b,
	0x54, 0x8a, 0x20, 0x17, 0x62, 0x2d, 0xae, 0x14, 0xa2, 0xfc, 0x50, 0xc9, 0x95, 0x6a, 0x07, 0x05,
	0x7a, 0xea, 0x3b, 0xb4, 0x8f, 0x51, 0xf4, 0x01, 0x7a, 0xed, 0xb1, 0xc7, 0x1e, 0x5b, 0xf7, 0x45,
	0x82, 0x5d, 0x92, 0x92, 0x65, 0x9b, 0x72, 0x72, 0xe3, 0xce, 0xcc, 0x6f, 0x76, 0x66, 0xf8, 0x1f,
	0x51, 0x70, 0x18, 0x32, 0xea, 0x38, 0x24, 0x08, 0x19, 0x61, 0xb6, 0xef, 0x35, 0xc9, 0xd4, 0x6e,
	0xce, 0x1f, 0x35, 0x57, 0xad, 0x8d, 0x69, 0xe0, 0x33, 0x1f, 0x97, 0xaf, 0x59, 0xc9, 0xd4, 0x6e,
	0xcc, 0x1f, 0x55, 0x1e, 0x4c, 0x7c, 0x7f, 0xe2, 0xd0, 0xa6, 0x08, 0x3a, 0x9b, 0x8d, 0x9b, 0xcc,
	0x76, 0x69, 0xc8, 0x88, 0x3b, 0x8d, 0x38, 0xe5, 0x3f, 0x04, 0xf7, 0x0c, 0xc2, 0x59, 0x9b, 0x51,
	0x83, 0x05, 0x94, 0xb8, 0x3a, 0xfd, 0x61, 0x46, 0x43, 0x86, 0x1f, 0xc2, 0x56, 0x98, 0x78, 0x4c,
	0xdb, 0x92, 0x51, 0x0d, 0xd5, 0x25, 0xbd, 0xb8, 0xb0, 0xf5, 0x2d, 0x7c, 0x1f, 0xa4, 0x50, 0x30,
	0xdc, 0x9f, 0x11, 0xfe, 0x42, 0x64, 0xe8, 0x5b, 0xf8, 0x27, 0x78, 0x10, 0x52, 0xcf, 0x32, 0x97,
	0x49, 0x46, 0xbe, 0xeb, 0x12, 0xcf, 0x0a, 0xcd, 0x20, 0xba, 0x42, 0xde, 0xac, 0xa1, 0x7a, 0x51,
	0x7d, 0xdc, 0xb8, 0xb5, 0xf8, 0x86, 0x41, 0x3d, 0x6b, 0x51, 0x5b, 0x27, 0x66, 0xe3, 0xea, 0x7a,
	0x1b, 0xfa, 0x41, 0xb8, 0xc6, 0xdf, 0x96, 0x20, 0x1f, 0x3f, 0x2a, 0x3f, 0xc3, 0xc1, 0xba, 0x54,
	0x58, 0x83, 0x1d, 0x7f, 0xc6, 0xa6, 0x33, 0x66, 0x8e, 0x03, 0xe2, 0xda, 0xde, 0x44, 0xb4, 0xba,
	0xa3, 0x56, 0x53, 0xea, 0x3a, 0x8e, 0xa2, 0xf4, 0xed, 0x88, 0x8a, 0x8f, 0x58, 0x86, 0x7c, 0xdc,
	0xa0, 0x9c, 0xa9, 0x6d, 0xd6, 0xb7, 0xf4, 0xe4, 0xa8, 0xfc, 0x81, 0x60, 0xef, 0xc6, 0x90, 0xc3,
	0xa9, 0xef, 0x85, 0x74, 0x75, 0x84, 0xe8, 0xda, 0x08, 0x7d, 0xa8, 0x04, 0x74, 0x44, 0xed, 0x39,
	0x35, 0x19, 0x75, 0xa8, 0x4b, 0x59, 0x70, 0x61, 0x06, 0x31, 0x2a, 0x06, 0x5e, 0x54, 0x9b, 0x29,
	0x55, 0xea, 0x11, 0x38, 0x4c, 0xb8, 0xe4, 0xc6, 0xde, 0x86, 0x2e, 0x07, 0x29, 0xbe, 0x36, 0x40,
	0x21, 0x79, 0x56, 0x5e, 0x82, 0x9c, 0x96, 0x03, 0x7f, 0x0d, 0xd2, 0xa2, 0x20, 0x51, 0x75, 0x51,
	0xad, 0xa5, 0xd4, 0xb1, 0x84, 0x97, 0x88, 0xf2, 0x4f, 0x06, 0xa4, 0x85, 0x03, 0x7f, 0x0e, 0xf9,
	0x77, 0x9b, 0x7c, 0x12, 0x8e, 0x31, 0x64, 0x2d, 0xc2, 0x88, 0x18, 0xc5, 0x96, 0x2e, 0x9e, 0xb1,
	0x0a, 0x65, 0xcb, 0xff, 0xd1, 0x73, 0x6c, 0xef, 0x7b, 0x73, 0x2c, 0x94, 0xe6, 0x8d, 0x2e, 0xcc,
	0x57, 0xaf, 0x85, 0xda, 0xb2, 0xfa, 0x6e, 0xe2, 0x3c, 0x4e, 0x7c, 0xbd, 0xd7, 0xd8, 0x00, 0x99,
	0x6f, 0x86, 0x39, 0xb6, 0x83, 0x90, 0x99, 0x67, 0x17, 0x8c, 0x9a, 0xf1, 0x8c, 0x2c, 0x39, 0x2b,
	0xda, 0xab, 0x34, 0xa2, 0x55, 0x6a, 0x24, 0xab, 0xd4, 0x18, 0x26, 0xab, 0xa4, 0x97, 0x39, 0x7b,
	0xcc, 0xd1, 0xf6, 0x05, 0xa3, 0xf1, 0xd0, 0x2c, 0x7c, 0x0a, 0x7b, 0x22, 0xa9, 0x43, 0x6e, 0xe4,
	0x7c, 0xef, 0xce, 0x9c, 0x1f, 0x72, 0x74, 0x40, 0xae, 0xa5, 0x7c, 0x08, 0x5b, 0xbc, 0x75, 0x6a,
	0xbe, 0xa2, 0xc4, 0xa2, 0x81, 0x9c, 0x13, 0x7d, 0x17, 0x85, 0xad, 0x27, 0x4c, 0xca, 0x9f, 0x08,
	0x3e, 0x1a, 0xd8, 0x21, 0x7b, 0x12, 0xf8, 0x33, 0xcf, 0x32, 0xa2, 0x01, 0x9e, 0x38, 0xc4, 0x5b,
	0xe8, 0xfd, 0x10, 0x3e, 0x98, 0x08, 0xa7, 0x19, 0x8f, 0x77, 0x29, 0xbd, 0xf7, 0x27, 0x57, 0xa9,
	0xbe, 0x85, 0x3f, 0x03, 0x89, 0xf8, 0xa1, 0x49, 0xc6, 0x8c, 0x06, 0xb1, 0xe0, 0xd6, 0x55, 0x5d,
	0x20, 0x7e, 0xd8, 0xe2, 0xb1, 0xf8, 0x0b, 0x00, 0x0e, 0x9e, 0xd1, 0xb1, 0x1f, 0xd0, 0x78, 0xd1,
	0xd7, 0x91, 0xfc, 0x9a, 0xb6, 0x08, 0x56, 0x4e, 0xa1, 0x9a, 0xd6, 0x40, 0x2c, 0xbf, 0x26, 0x64,
	0xa7, 0x0e, 0xf1, 0x64, 0x54, 0xdb, 0xac, 0x17, 0xd5, 0xfb, 0x29, 0x6a, 0xe1, 0x8c, 0x2e, 0x02,
	0x95, 0xdf, 0xb3, 0x90, 0xe5, 0x47, 0xbc, 0x07, 0x79, 0x6e, 0x58, 0x76, 0x9c, 0xe3, 0xc7, 0xbe,
	0x85, 0xbf, 0x84, 0x1c, 0xc7, 0x67, 0xa1, 0xe8, 0x72, 0x47, 0x55, 0xd6, 0x24, 0x6d, 0x18, 0x22,
	0x52, 0x8f, 0x09, 0xbc, 0x0f, 0x05, 0xe6, 0x50, 0xd3, 0xb1, 0x3d, 0xde, 0xe9, 0x66, 0x5d, 0xd2,
	0xf3, 0xcc, 0xa1, 0x03, 0xdb, 0xa3, 0xf8, 0x08, 0xf8, 0x48, 0x4c, 0xfe, 0x32, 0xdf, 0x42, 0x48,
	0x79, 0xe2, 0x87, 0xfc, 0xc4, 0x31, 0x27, 0xc1, 0xee, 0xd6, 0x4a, 0xde, 0x89, 0xb1, 0x6f, 0xe0,
	0x60, 0x21, 0xfd, 0x11, 0xf5, 0x18, 0x0d, 0x56, 0x37, 0x20, 0x27, 0x36, 0x60, 0x3f, 0x89, 0xe9,
	0x88, 0x90, 0xab, 0x7b, 0xf0, 0x15, 0x54, 0x66, 0xd3, 0x54, 0x3c, 0x2f, 0xf0, 0xbd, 0x28, 0xe2,
	0x26, 0xac, 0x42, 0xd9, 0x25, 0xe7, 0x26, 0x75, 0xe8, 0x3c, 0x92, 0x95, 0x45, 0x27, 0x01, 0xa5,
	0xa1, 0x5c, 0xa8, 0xa1, 0x3a, 0xd2, 0x77, 0x5d, 0x72, 0xae, 0x25, 0xbe, 0x6e, 0xe4, 0xc2, 0x3d,
	0xc0, 0xab, 0x8c, 0x68, 0x59, 0xba, 0xb3, 0xe5, 0xd2, 0xd5, 0x64, 0xdc, 0xac, 0x3c, 0x83, 0x5c,
	0xf4, 0x5a, 0xf0, 0x16, 0x14, 0x74, 0xcd, 0xd0, 0xf4, 0xef, 0xb4, 0x6e, 0x69, 0x03, 0x6f, 0x83,
	0xa4, 0xbd, 0xd0, 0x3a, 0xcf, 0x87, 0xfd, 0xa7, 0x4f, 0x4a, 0x88, 0x1f, 0x8d, 0xe7, 0x9d, 0x8e,
	0xa6, 0x75, 0xb5, 0x6e, 0x29, 0x83, 0x01, 0x72, 0xc7, 0xad, 0xfe, 0x40, 0xeb, 0x96, 0x36, 0xb9,
	0xab, 0xd3, 0x7a, 0xda, 0xd1, 0x06, 0xfc, 0x98, 0x3d, 0x3c, 0x84, 0x7c, 0xf2, 0xd3, 0xbe, 0x0d,
	0x52, 0xbb, 0x3f, 0x34, 0x86, 0xba, 0xd6, 0xfa, 0xb6, 0xb4, 0x81, 0x0b, 0x90, 0x6d, 0xbd, 0x50,
	0x8f, 0x4a, 0x08, 0xe7, 0x20, 0xd3, 0x3f, 0x2d, 0x65, 0xd4, 0xdf, 0x32, 0x50, 0x36, 0x22, 0xbd,
	0xc4, 0x82, 0x35, 0x68, 0x30, 0xb7, 0x47, 0x14, 0xff, 0x82, 0xe0, 0xde, 0xed, 0x6a, 0xc6, 0x9f,
	0xa6, 0x48, 0x6c, 0xed, 0xf6, 0x56, 0x8e, 0xde, 0x91, 0x8a, 0x57, 0xe6, 0x1c, 0x76, 0x9f, 0x4d,
	0xa9, 0x77, 0xed, 0x33, 0x84, 0x3f, 0x4e, 0xfb, 0xf6, 0xde, 0xfa, 0x9f, 0xa0, 0xd2, 0x78, 0xdb,
	0xf0, 0xe8, 0xd6, 0x3a, 0xfa, 0x04, 0xb5, 0xf5, 0xbf, 0x2e, 0xab, 0xe8, 0xef, 0xcb, 0x2a, 0xfa,
	0xf7, 0xb2, 0x8a, 0x7e, 0xfd, 0xbf, 0xba, 0x01, 0xfb, 0x23, 0xdf, 0xbd, 0x3d, 0x51, 0x7b, 0xd7,
	0x58, 0x31, 0x9f, 0xf0, 0x37, 0x7f, 0x82, 0x5e, 0xee, 0xac, 0x46, 0x9f, 0xe5, 0x84, 0x24, 0x1e,
	0xbf, 0x09, 0x00, 0x00, 0xff, 0xff, 0x7f, 0x3b, 0xcd, 0x7b, 0x23, 0x09, 0x00, 0x00,
}
