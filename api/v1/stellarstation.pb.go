// Code generated by protoc-gen-go. DO NOT EDIT.
// source: stellarstation/api/v1/stellarstation.proto

package v1 // import "github.com/infostellarinc/go-stellarstation/api/v1"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import timestamp "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// A type of framing of a binary payload used in satellite communicaation.
type Framing int32

const (
	// No framing done in the API. All payloads are assumed to be pre-framed and ready for
	// transmission to the satellite or API client with no additional processing.
	Framing_BITSTREAM Framing = 0
	// AX.25 (Amateur X.25) framing - https://en.wikipedia.org/wiki/AX.25
	Framing_AX25 Framing = 1
	// No framing or demodulation done in the API. Raw IQ data is sent to the API client with no
	// additional processing.
	Framing_IQ Framing = 2
	// A decoded PNG image frame.
	Framing_IMAGE_PNG Framing = 3
)

var Framing_name = map[int32]string{
	0: "BITSTREAM",
	1: "AX25",
	2: "IQ",
	3: "IMAGE_PNG",
}
var Framing_value = map[string]int32{
	"BITSTREAM": 0,
	"AX25":      1,
	"IQ":        2,
	"IMAGE_PNG": 3,
}

func (x Framing) String() string {
	return proto.EnumName(Framing_name, int32(x))
}
func (Framing) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_68cc2fa00127c403, []int{0}
}

// A description of the status of a plan.
type Plan_Status int32

const (
	// The plan is reserved for execution in the future at `aos_time`.
	Plan_RESERVED Plan_Status = 0
	// The plan is currently executing and will end in the future at `los_time`.
	Plan_EXECUTING Plan_Status = 1
	// The plan already finished executing successfully.
	Plan_SUCCEEDED Plan_Status = 2
	// The plan failed to execute correctly.
	Plan_FAILED Plan_Status = 3
	// The plan was canceled. This can be explicitly by calling `CancelPlan` or implicit due to
	// cancellation by the ground station in the plan (i.e., due to bad weather).
	Plan_CANCELED Plan_Status = 4
)

var Plan_Status_name = map[int32]string{
	0: "RESERVED",
	1: "EXECUTING",
	2: "SUCCEEDED",
	3: "FAILED",
	4: "CANCELED",
}
var Plan_Status_value = map[string]int32{
	"RESERVED":  0,
	"EXECUTING": 1,
	"SUCCEEDED": 2,
	"FAILED":    3,
	"CANCELED":  4,
}

func (x Plan_Status) String() string {
	return proto.EnumName(Plan_Status_name, int32(x))
}
func (Plan_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_68cc2fa00127c403, []int{10, 0}
}

// Request for the `OpenSatelliteStream` method.
type SatelliteStreamRequest struct {
	// The ID of the satellite to open a stream with. The ID of a satellite can be found on the
	// StellarStation Console page for the satellite.
	SatelliteId string `protobuf:"bytes,1,opt,name=satellite_id,json=satelliteId,proto3" json:"satellite_id,omitempty"`
	// The `SatelliteStreamResponse.stream_id` from a previously opened stream to resume. If the
	// specified stream has already expired or been closed, the stream is closed with a `ABORTED`
	// error.
	StreamId string `protobuf:"bytes,2,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	// A request to send on the satellite stream. Currently only command sending to the satellite is
	// supported. The request does not need to be filled on the first request to
	// `OpenSatelliteStream`.
	//
	// Types that are valid to be assigned to Request:
	//	*SatelliteStreamRequest_SendSatelliteCommandsRequest
	Request isSatelliteStreamRequest_Request `protobuf_oneof:"Request"`
	// The `Framing` types to accept, for satellites that have been configured for multiple framings
	// (e.g., IQ + AX25). If empty, all framings produced by the satellite will be returned.
	AcceptedFraming      []Framing `protobuf:"varint,4,rep,packed,name=accepted_framing,json=acceptedFraming,proto3,enum=stellarstation.api.v1.Framing" json:"accepted_framing,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *SatelliteStreamRequest) Reset()         { *m = SatelliteStreamRequest{} }
func (m *SatelliteStreamRequest) String() string { return proto.CompactTextString(m) }
func (*SatelliteStreamRequest) ProtoMessage()    {}
func (*SatelliteStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_68cc2fa00127c403, []int{0}
}
func (m *SatelliteStreamRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SatelliteStreamRequest.Unmarshal(m, b)
}
func (m *SatelliteStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SatelliteStreamRequest.Marshal(b, m, deterministic)
}
func (dst *SatelliteStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SatelliteStreamRequest.Merge(dst, src)
}
func (m *SatelliteStreamRequest) XXX_Size() int {
	return xxx_messageInfo_SatelliteStreamRequest.Size(m)
}
func (m *SatelliteStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SatelliteStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SatelliteStreamRequest proto.InternalMessageInfo

func (m *SatelliteStreamRequest) GetSatelliteId() string {
	if m != nil {
		return m.SatelliteId
	}
	return ""
}

func (m *SatelliteStreamRequest) GetStreamId() string {
	if m != nil {
		return m.StreamId
	}
	return ""
}

type isSatelliteStreamRequest_Request interface {
	isSatelliteStreamRequest_Request()
}

type SatelliteStreamRequest_SendSatelliteCommandsRequest struct {
	SendSatelliteCommandsRequest *SendSatelliteCommandsRequest `protobuf:"bytes,3,opt,name=send_satellite_commands_request,json=sendSatelliteCommandsRequest,proto3,oneof"`
}

func (*SatelliteStreamRequest_SendSatelliteCommandsRequest) isSatelliteStreamRequest_Request() {}

func (m *SatelliteStreamRequest) GetRequest() isSatelliteStreamRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *SatelliteStreamRequest) GetSendSatelliteCommandsRequest() *SendSatelliteCommandsRequest {
	if x, ok := m.GetRequest().(*SatelliteStreamRequest_SendSatelliteCommandsRequest); ok {
		return x.SendSatelliteCommandsRequest
	}
	return nil
}

func (m *SatelliteStreamRequest) GetAcceptedFraming() []Framing {
	if m != nil {
		return m.AcceptedFraming
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SatelliteStreamRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SatelliteStreamRequest_OneofMarshaler, _SatelliteStreamRequest_OneofUnmarshaler, _SatelliteStreamRequest_OneofSizer, []interface{}{
		(*SatelliteStreamRequest_SendSatelliteCommandsRequest)(nil),
	}
}

func _SatelliteStreamRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SatelliteStreamRequest)
	// Request
	switch x := m.Request.(type) {
	case *SatelliteStreamRequest_SendSatelliteCommandsRequest:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SendSatelliteCommandsRequest); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SatelliteStreamRequest.Request has unexpected type %T", x)
	}
	return nil
}

func _SatelliteStreamRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SatelliteStreamRequest)
	switch tag {
	case 3: // Request.send_satellite_commands_request
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SendSatelliteCommandsRequest)
		err := b.DecodeMessage(msg)
		m.Request = &SatelliteStreamRequest_SendSatelliteCommandsRequest{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SatelliteStreamRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SatelliteStreamRequest)
	// Request
	switch x := m.Request.(type) {
	case *SatelliteStreamRequest_SendSatelliteCommandsRequest:
		s := proto.Size(x.SendSatelliteCommandsRequest)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A request to send commands to a satellite.
//
// Next ID: 1
type SendSatelliteCommandsRequest struct {
	// The command frames to send to the satellite. All commands will be transmitted in sequence
	// immediately, during which time telemetry will not be received. After all commands have been
	// transmitted, telemetry receive will be immediately re-enabled. The maximum size of each command
	// is 2MB. If a command larger than 2MB is received, the stream will be closed with a
	// `RESOURCE_EXHAUSTED` error.
	Command              [][]byte `protobuf:"bytes,2,rep,name=command,proto3" json:"command,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SendSatelliteCommandsRequest) Reset()         { *m = SendSatelliteCommandsRequest{} }
func (m *SendSatelliteCommandsRequest) String() string { return proto.CompactTextString(m) }
func (*SendSatelliteCommandsRequest) ProtoMessage()    {}
func (*SendSatelliteCommandsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_68cc2fa00127c403, []int{1}
}
func (m *SendSatelliteCommandsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SendSatelliteCommandsRequest.Unmarshal(m, b)
}
func (m *SendSatelliteCommandsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SendSatelliteCommandsRequest.Marshal(b, m, deterministic)
}
func (dst *SendSatelliteCommandsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendSatelliteCommandsRequest.Merge(dst, src)
}
func (m *SendSatelliteCommandsRequest) XXX_Size() int {
	return xxx_messageInfo_SendSatelliteCommandsRequest.Size(m)
}
func (m *SendSatelliteCommandsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SendSatelliteCommandsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SendSatelliteCommandsRequest proto.InternalMessageInfo

func (m *SendSatelliteCommandsRequest) GetCommand() [][]byte {
	if m != nil {
		return m.Command
	}
	return nil
}

// A response from the `OpenSatelliteStream` method.
type SatelliteStreamResponse struct {
	// The ID of this stream, which can be used in a subsequent call to `OpenSatelliteStream` to
	// resume this stream on interruption (e.g., if a network failure causes the connection to be
	// closed mid-stream). Telemetry received on a previously opened stream with no current listener
	// will be buffered for a maximum of 1 minute, and the stream itself will be cancelled and no more
	// buffering will occur if no client resumes the stream with `OpenSatelliteStream` within 10
	// minutes.
	StreamId string `protobuf:"bytes,1,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	// A response on the stream. Currently the only type of response is telemetry received from the
	// satellite.
	//
	// Types that are valid to be assigned to Response:
	//	*SatelliteStreamResponse_ReceiveTelemetryResponse
	Response             isSatelliteStreamResponse_Response `protobuf_oneof:"Response"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *SatelliteStreamResponse) Reset()         { *m = SatelliteStreamResponse{} }
func (m *SatelliteStreamResponse) String() string { return proto.CompactTextString(m) }
func (*SatelliteStreamResponse) ProtoMessage()    {}
func (*SatelliteStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_68cc2fa00127c403, []int{2}
}
func (m *SatelliteStreamResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SatelliteStreamResponse.Unmarshal(m, b)
}
func (m *SatelliteStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SatelliteStreamResponse.Marshal(b, m, deterministic)
}
func (dst *SatelliteStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SatelliteStreamResponse.Merge(dst, src)
}
func (m *SatelliteStreamResponse) XXX_Size() int {
	return xxx_messageInfo_SatelliteStreamResponse.Size(m)
}
func (m *SatelliteStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SatelliteStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SatelliteStreamResponse proto.InternalMessageInfo

func (m *SatelliteStreamResponse) GetStreamId() string {
	if m != nil {
		return m.StreamId
	}
	return ""
}

type isSatelliteStreamResponse_Response interface {
	isSatelliteStreamResponse_Response()
}

type SatelliteStreamResponse_ReceiveTelemetryResponse struct {
	ReceiveTelemetryResponse *ReceiveTelemetryResponse `protobuf:"bytes,2,opt,name=receive_telemetry_response,json=receiveTelemetryResponse,proto3,oneof"`
}

func (*SatelliteStreamResponse_ReceiveTelemetryResponse) isSatelliteStreamResponse_Response() {}

func (m *SatelliteStreamResponse) GetResponse() isSatelliteStreamResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *SatelliteStreamResponse) GetReceiveTelemetryResponse() *ReceiveTelemetryResponse {
	if x, ok := m.GetResponse().(*SatelliteStreamResponse_ReceiveTelemetryResponse); ok {
		return x.ReceiveTelemetryResponse
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SatelliteStreamResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SatelliteStreamResponse_OneofMarshaler, _SatelliteStreamResponse_OneofUnmarshaler, _SatelliteStreamResponse_OneofSizer, []interface{}{
		(*SatelliteStreamResponse_ReceiveTelemetryResponse)(nil),
	}
}

func _SatelliteStreamResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SatelliteStreamResponse)
	// Response
	switch x := m.Response.(type) {
	case *SatelliteStreamResponse_ReceiveTelemetryResponse:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ReceiveTelemetryResponse); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SatelliteStreamResponse.Response has unexpected type %T", x)
	}
	return nil
}

func _SatelliteStreamResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SatelliteStreamResponse)
	switch tag {
	case 2: // Response.receive_telemetry_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ReceiveTelemetryResponse)
		err := b.DecodeMessage(msg)
		m.Response = &SatelliteStreamResponse_ReceiveTelemetryResponse{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SatelliteStreamResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SatelliteStreamResponse)
	// Response
	switch x := m.Response.(type) {
	case *SatelliteStreamResponse_ReceiveTelemetryResponse:
		s := proto.Size(x.ReceiveTelemetryResponse)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A response from a satellite containing telemetry.
type ReceiveTelemetryResponse struct {
	// The telemetry received.
	Telemetry            *Telemetry `protobuf:"bytes,1,opt,name=telemetry,proto3" json:"telemetry,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ReceiveTelemetryResponse) Reset()         { *m = ReceiveTelemetryResponse{} }
func (m *ReceiveTelemetryResponse) String() string { return proto.CompactTextString(m) }
func (*ReceiveTelemetryResponse) ProtoMessage()    {}
func (*ReceiveTelemetryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_68cc2fa00127c403, []int{3}
}
func (m *ReceiveTelemetryResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReceiveTelemetryResponse.Unmarshal(m, b)
}
func (m *ReceiveTelemetryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReceiveTelemetryResponse.Marshal(b, m, deterministic)
}
func (dst *ReceiveTelemetryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiveTelemetryResponse.Merge(dst, src)
}
func (m *ReceiveTelemetryResponse) XXX_Size() int {
	return xxx_messageInfo_ReceiveTelemetryResponse.Size(m)
}
func (m *ReceiveTelemetryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiveTelemetryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiveTelemetryResponse proto.InternalMessageInfo

func (m *ReceiveTelemetryResponse) GetTelemetry() *Telemetry {
	if m != nil {
		return m.Telemetry
	}
	return nil
}

// A chunk or frame of telemetry data that has been received from a satellite.
type Telemetry struct {
	// The framing of this telemetry data. If `RAW`, this telemetry will be an arbitrarily sized
	// chunk of the bitstream.
	Framing Framing `protobuf:"varint,1,opt,name=framing,proto3,enum=stellarstation.api.v1.Framing" json:"framing,omitempty"`
	// The payload of this telemetry.
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	// The actual downlink frequency, in Hz, used when receiving `data`, including adjustments for
	// doppler shift.
	DownlinkFrequencyHz uint64 `protobuf:"varint,3,opt,name=downlink_frequency_hz,json=downlinkFrequencyHz,proto3" json:"downlink_frequency_hz,omitempty"`
	// Timestamp when the first byte of `data` was received.
	TimeFirstByteReceived *timestamp.Timestamp `protobuf:"bytes,4,opt,name=time_first_byte_received,json=timeFirstByteReceived,proto3" json:"time_first_byte_received,omitempty"`
	// Timestamp when the last byte of `data` was received.
	TimeLastByteReceived *timestamp.Timestamp `protobuf:"bytes,5,opt,name=time_last_byte_received,json=timeLastByteReceived,proto3" json:"time_last_byte_received,omitempty"`
	// The binary header of the telemetry frame, if `framing` is not `RAW`.
	//
	// * AX25 - This is either Address + Control, or Address + Control + PID. The checksum is not
	//          returned.
	FrameHeader          []byte   `protobuf:"bytes,6,opt,name=frame_header,json=frameHeader,proto3" json:"frame_header,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Telemetry) Reset()         { *m = Telemetry{} }
func (m *Telemetry) String() string { return proto.CompactTextString(m) }
func (*Telemetry) ProtoMessage()    {}
func (*Telemetry) Descriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_68cc2fa00127c403, []int{4}
}
func (m *Telemetry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Telemetry.Unmarshal(m, b)
}
func (m *Telemetry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Telemetry.Marshal(b, m, deterministic)
}
func (dst *Telemetry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Telemetry.Merge(dst, src)
}
func (m *Telemetry) XXX_Size() int {
	return xxx_messageInfo_Telemetry.Size(m)
}
func (m *Telemetry) XXX_DiscardUnknown() {
	xxx_messageInfo_Telemetry.DiscardUnknown(m)
}

var xxx_messageInfo_Telemetry proto.InternalMessageInfo

func (m *Telemetry) GetFraming() Framing {
	if m != nil {
		return m.Framing
	}
	return Framing_BITSTREAM
}

func (m *Telemetry) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Telemetry) GetDownlinkFrequencyHz() uint64 {
	if m != nil {
		return m.DownlinkFrequencyHz
	}
	return 0
}

func (m *Telemetry) GetTimeFirstByteReceived() *timestamp.Timestamp {
	if m != nil {
		return m.TimeFirstByteReceived
	}
	return nil
}

func (m *Telemetry) GetTimeLastByteReceived() *timestamp.Timestamp {
	if m != nil {
		return m.TimeLastByteReceived
	}
	return nil
}

func (m *Telemetry) GetFrameHeader() []byte {
	if m != nil {
		return m.FrameHeader
	}
	return nil
}

// Request for the `ListUpcomingAvailablePasses` method.
type ListUpcomingAvailablePassesRequest struct {
	// The ID of the satellite to list passes for. The ID of a satellite can be found on the
	// StellarStation Console page for the satellite.
	SatelliteId          string   `protobuf:"bytes,1,opt,name=satellite_id,json=satelliteId,proto3" json:"satellite_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListUpcomingAvailablePassesRequest) Reset()         { *m = ListUpcomingAvailablePassesRequest{} }
func (m *ListUpcomingAvailablePassesRequest) String() string { return proto.CompactTextString(m) }
func (*ListUpcomingAvailablePassesRequest) ProtoMessage()    {}
func (*ListUpcomingAvailablePassesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_68cc2fa00127c403, []int{5}
}
func (m *ListUpcomingAvailablePassesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListUpcomingAvailablePassesRequest.Unmarshal(m, b)
}
func (m *ListUpcomingAvailablePassesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListUpcomingAvailablePassesRequest.Marshal(b, m, deterministic)
}
func (dst *ListUpcomingAvailablePassesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUpcomingAvailablePassesRequest.Merge(dst, src)
}
func (m *ListUpcomingAvailablePassesRequest) XXX_Size() int {
	return xxx_messageInfo_ListUpcomingAvailablePassesRequest.Size(m)
}
func (m *ListUpcomingAvailablePassesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUpcomingAvailablePassesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListUpcomingAvailablePassesRequest proto.InternalMessageInfo

func (m *ListUpcomingAvailablePassesRequest) GetSatelliteId() string {
	if m != nil {
		return m.SatelliteId
	}
	return ""
}

// Response for the `ListUpcomingAvailablePasses` method.
type ListUpcomingAvailablePassesResponse struct {
	// The upcoming, schedulable passes for the satellite.
	Pass                 []*Pass  `protobuf:"bytes,1,rep,name=pass,proto3" json:"pass,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListUpcomingAvailablePassesResponse) Reset()         { *m = ListUpcomingAvailablePassesResponse{} }
func (m *ListUpcomingAvailablePassesResponse) String() string { return proto.CompactTextString(m) }
func (*ListUpcomingAvailablePassesResponse) ProtoMessage()    {}
func (*ListUpcomingAvailablePassesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_68cc2fa00127c403, []int{6}
}
func (m *ListUpcomingAvailablePassesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListUpcomingAvailablePassesResponse.Unmarshal(m, b)
}
func (m *ListUpcomingAvailablePassesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListUpcomingAvailablePassesResponse.Marshal(b, m, deterministic)
}
func (dst *ListUpcomingAvailablePassesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUpcomingAvailablePassesResponse.Merge(dst, src)
}
func (m *ListUpcomingAvailablePassesResponse) XXX_Size() int {
	return xxx_messageInfo_ListUpcomingAvailablePassesResponse.Size(m)
}
func (m *ListUpcomingAvailablePassesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUpcomingAvailablePassesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListUpcomingAvailablePassesResponse proto.InternalMessageInfo

func (m *ListUpcomingAvailablePassesResponse) GetPass() []*Pass {
	if m != nil {
		return m.Pass
	}
	return nil
}

// Request for the `ReservePass` method.
type ReservePassRequest struct {
	// The token that specifies the pass, as returned in `Pass.reservation_token`.
	ReservationToken     string   `protobuf:"bytes,1,opt,name=reservation_token,json=reservationToken,proto3" json:"reservation_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReservePassRequest) Reset()         { *m = ReservePassRequest{} }
func (m *ReservePassRequest) String() string { return proto.CompactTextString(m) }
func (*ReservePassRequest) ProtoMessage()    {}
func (*ReservePassRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_68cc2fa00127c403, []int{7}
}
func (m *ReservePassRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReservePassRequest.Unmarshal(m, b)
}
func (m *ReservePassRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReservePassRequest.Marshal(b, m, deterministic)
}
func (dst *ReservePassRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReservePassRequest.Merge(dst, src)
}
func (m *ReservePassRequest) XXX_Size() int {
	return xxx_messageInfo_ReservePassRequest.Size(m)
}
func (m *ReservePassRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReservePassRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReservePassRequest proto.InternalMessageInfo

func (m *ReservePassRequest) GetReservationToken() string {
	if m != nil {
		return m.ReservationToken
	}
	return ""
}

// Response for the `ReservePass` method.
type ReservePassResponse struct {
	// The reserved plan.
	Plan                 *Plan    `protobuf:"bytes,1,opt,name=plan,proto3" json:"plan,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReservePassResponse) Reset()         { *m = ReservePassResponse{} }
func (m *ReservePassResponse) String() string { return proto.CompactTextString(m) }
func (*ReservePassResponse) ProtoMessage()    {}
func (*ReservePassResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_68cc2fa00127c403, []int{8}
}
func (m *ReservePassResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReservePassResponse.Unmarshal(m, b)
}
func (m *ReservePassResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReservePassResponse.Marshal(b, m, deterministic)
}
func (dst *ReservePassResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReservePassResponse.Merge(dst, src)
}
func (m *ReservePassResponse) XXX_Size() int {
	return xxx_messageInfo_ReservePassResponse.Size(m)
}
func (m *ReservePassResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReservePassResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReservePassResponse proto.InternalMessageInfo

func (m *ReservePassResponse) GetPlan() *Plan {
	if m != nil {
		return m.Plan
	}
	return nil
}

// A pass during which a satellite can be communicated with from a given ground station.
type Pass struct {
	// A unique token for this pass that can be used for scheduling it.
	ReservationToken string `protobuf:"bytes,1,opt,name=reservation_token,json=reservationToken,proto3" json:"reservation_token,omitempty"`
	// The time of Acquisition of Signal (AOS) between the ground station and satellite in this pass.
	AosTime *timestamp.Timestamp `protobuf:"bytes,2,opt,name=aos_time,json=aosTime,proto3" json:"aos_time,omitempty"`
	// The time of Loss of Signal (LOS) between the ground station and satellite in this pass.
	LosTime *timestamp.Timestamp `protobuf:"bytes,3,opt,name=los_time,json=losTime,proto3" json:"los_time,omitempty"`
	// The latitude, in degrees, of the ground station's location.
	GroundStationLatitude float64 `protobuf:"fixed64,4,opt,name=ground_station_latitude,json=groundStationLatitude,proto3" json:"ground_station_latitude,omitempty"`
	// The longitude, in degrees, of the ground station's location.
	GroundStationLongitude float64 `protobuf:"fixed64,5,opt,name=ground_station_longitude,json=groundStationLongitude,proto3" json:"ground_station_longitude,omitempty"`
	// The ISO 3166-1 alpha-2 2-letter country code for the ground station's location.
	// See https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
	GroundStationCountryCode string `protobuf:"bytes,6,opt,name=ground_station_country_code,json=groundStationCountryCode,proto3" json:"ground_station_country_code,omitempty"`
	// The max elevation during the pass, in degrees.
	MaxElevationDegrees float64 `protobuf:"fixed64,7,opt,name=max_elevation_degrees,json=maxElevationDegrees,proto3" json:"max_elevation_degrees,omitempty"`
	// The time of the max elevation during the pass.
	MaxElevationTime *timestamp.Timestamp `protobuf:"bytes,8,opt,name=max_elevation_time,json=maxElevationTime,proto3" json:"max_elevation_time,omitempty"`
	// The center frequency, in Hz, for downlinking in this pass. 0 if downlink is not available in
	// this pass.
	DownlinkCenterFrequencyHz uint64 `protobuf:"varint,9,opt,name=downlink_center_frequency_hz,json=downlinkCenterFrequencyHz,proto3" json:"downlink_center_frequency_hz,omitempty"`
	// The center frequency, in Hz, for uplinking in this pass. 0 if uplink is not available in
	// this pass.
	UplinkCenterFrequencyHz uint64   `protobuf:"varint,10,opt,name=uplink_center_frequency_hz,json=uplinkCenterFrequencyHz,proto3" json:"uplink_center_frequency_hz,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *Pass) Reset()         { *m = Pass{} }
func (m *Pass) String() string { return proto.CompactTextString(m) }
func (*Pass) ProtoMessage()    {}
func (*Pass) Descriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_68cc2fa00127c403, []int{9}
}
func (m *Pass) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Pass.Unmarshal(m, b)
}
func (m *Pass) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Pass.Marshal(b, m, deterministic)
}
func (dst *Pass) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pass.Merge(dst, src)
}
func (m *Pass) XXX_Size() int {
	return xxx_messageInfo_Pass.Size(m)
}
func (m *Pass) XXX_DiscardUnknown() {
	xxx_messageInfo_Pass.DiscardUnknown(m)
}

var xxx_messageInfo_Pass proto.InternalMessageInfo

func (m *Pass) GetReservationToken() string {
	if m != nil {
		return m.ReservationToken
	}
	return ""
}

func (m *Pass) GetAosTime() *timestamp.Timestamp {
	if m != nil {
		return m.AosTime
	}
	return nil
}

func (m *Pass) GetLosTime() *timestamp.Timestamp {
	if m != nil {
		return m.LosTime
	}
	return nil
}

func (m *Pass) GetGroundStationLatitude() float64 {
	if m != nil {
		return m.GroundStationLatitude
	}
	return 0
}

func (m *Pass) GetGroundStationLongitude() float64 {
	if m != nil {
		return m.GroundStationLongitude
	}
	return 0
}

func (m *Pass) GetGroundStationCountryCode() string {
	if m != nil {
		return m.GroundStationCountryCode
	}
	return ""
}

func (m *Pass) GetMaxElevationDegrees() float64 {
	if m != nil {
		return m.MaxElevationDegrees
	}
	return 0
}

func (m *Pass) GetMaxElevationTime() *timestamp.Timestamp {
	if m != nil {
		return m.MaxElevationTime
	}
	return nil
}

func (m *Pass) GetDownlinkCenterFrequencyHz() uint64 {
	if m != nil {
		return m.DownlinkCenterFrequencyHz
	}
	return 0
}

func (m *Pass) GetUplinkCenterFrequencyHz() uint64 {
	if m != nil {
		return m.UplinkCenterFrequencyHz
	}
	return 0
}

// A plan, specifying a time range within which a satellite will be communicated with.
type Plan struct {
	// The unique ID of the plan.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The id of the satellite to be tracked in the plan.
	SatelliteId string `protobuf:"bytes,2,opt,name=satellite_id,json=satelliteId,proto3" json:"satellite_id,omitempty"`
	// The status of this plan.
	Status Plan_Status `protobuf:"varint,3,opt,name=status,proto3,enum=stellarstation.api.v1.Plan_Status" json:"status,omitempty"`
	// The time of Acquisition of Signal (AOS) between the ground station and satellite in this plan.
	AosTime *timestamp.Timestamp `protobuf:"bytes,4,opt,name=aos_time,json=aosTime,proto3" json:"aos_time,omitempty"`
	// The time of Loss of Signal (LOS) between the ground station and satellite in this plan.
	LosTime *timestamp.Timestamp `protobuf:"bytes,5,opt,name=los_time,json=losTime,proto3" json:"los_time,omitempty"`
	// The latitude, in degrees, of the ground station's location.
	GroundStationLatitude float64 `protobuf:"fixed64,6,opt,name=ground_station_latitude,json=groundStationLatitude,proto3" json:"ground_station_latitude,omitempty"`
	// The longitude, in degrees, of the ground station's location.
	GroundStationLongitude float64 `protobuf:"fixed64,7,opt,name=ground_station_longitude,json=groundStationLongitude,proto3" json:"ground_station_longitude,omitempty"`
	// The ISO 3166-1 alpha-2 2-letter country code for the ground station's location.
	// See https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
	GroundStationCountryCode string `protobuf:"bytes,8,opt,name=ground_station_country_code,json=groundStationCountryCode,proto3" json:"ground_station_country_code,omitempty"`
	// The max elevation during the plan, in degrees.
	MaxElevationDegrees float64 `protobuf:"fixed64,9,opt,name=max_elevation_degrees,json=maxElevationDegrees,proto3" json:"max_elevation_degrees,omitempty"`
	// The time of the max elevation during the plan.
	MaxElevationTime *timestamp.Timestamp `protobuf:"bytes,10,opt,name=max_elevation_time,json=maxElevationTime,proto3" json:"max_elevation_time,omitempty"`
	// The center frequency, in Hz, for downlinking in this plan. 0 if downlink is not available in
	// this plan.
	DownlinkCenterFrequencyHz uint64 `protobuf:"varint,11,opt,name=downlink_center_frequency_hz,json=downlinkCenterFrequencyHz,proto3" json:"downlink_center_frequency_hz,omitempty"`
	// The center frequency, in Hz, for uplinking in this plan. 0 if uplink is not available in
	// this plan.
	UplinkCenterFrequencyHz uint64   `protobuf:"varint,12,opt,name=uplink_center_frequency_hz,json=uplinkCenterFrequencyHz,proto3" json:"uplink_center_frequency_hz,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *Plan) Reset()         { *m = Plan{} }
func (m *Plan) String() string { return proto.CompactTextString(m) }
func (*Plan) ProtoMessage()    {}
func (*Plan) Descriptor() ([]byte, []int) {
	return fileDescriptor_stellarstation_68cc2fa00127c403, []int{10}
}
func (m *Plan) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Plan.Unmarshal(m, b)
}
func (m *Plan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Plan.Marshal(b, m, deterministic)
}
func (dst *Plan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Plan.Merge(dst, src)
}
func (m *Plan) XXX_Size() int {
	return xxx_messageInfo_Plan.Size(m)
}
func (m *Plan) XXX_DiscardUnknown() {
	xxx_messageInfo_Plan.DiscardUnknown(m)
}

var xxx_messageInfo_Plan proto.InternalMessageInfo

func (m *Plan) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Plan) GetSatelliteId() string {
	if m != nil {
		return m.SatelliteId
	}
	return ""
}

func (m *Plan) GetStatus() Plan_Status {
	if m != nil {
		return m.Status
	}
	return Plan_RESERVED
}

func (m *Plan) GetAosTime() *timestamp.Timestamp {
	if m != nil {
		return m.AosTime
	}
	return nil
}

func (m *Plan) GetLosTime() *timestamp.Timestamp {
	if m != nil {
		return m.LosTime
	}
	return nil
}

func (m *Plan) GetGroundStationLatitude() float64 {
	if m != nil {
		return m.GroundStationLatitude
	}
	return 0
}

func (m *Plan) GetGroundStationLongitude() float64 {
	if m != nil {
		return m.GroundStationLongitude
	}
	return 0
}

func (m *Plan) GetGroundStationCountryCode() string {
	if m != nil {
		return m.GroundStationCountryCode
	}
	return ""
}

func (m *Plan) GetMaxElevationDegrees() float64 {
	if m != nil {
		return m.MaxElevationDegrees
	}
	return 0
}

func (m *Plan) GetMaxElevationTime() *timestamp.Timestamp {
	if m != nil {
		return m.MaxElevationTime
	}
	return nil
}

func (m *Plan) GetDownlinkCenterFrequencyHz() uint64 {
	if m != nil {
		return m.DownlinkCenterFrequencyHz
	}
	return 0
}

func (m *Plan) GetUplinkCenterFrequencyHz() uint64 {
	if m != nil {
		return m.UplinkCenterFrequencyHz
	}
	return 0
}

func init() {
	proto.RegisterType((*SatelliteStreamRequest)(nil), "stellarstation.api.v1.SatelliteStreamRequest")
	proto.RegisterType((*SendSatelliteCommandsRequest)(nil), "stellarstation.api.v1.SendSatelliteCommandsRequest")
	proto.RegisterType((*SatelliteStreamResponse)(nil), "stellarstation.api.v1.SatelliteStreamResponse")
	proto.RegisterType((*ReceiveTelemetryResponse)(nil), "stellarstation.api.v1.ReceiveTelemetryResponse")
	proto.RegisterType((*Telemetry)(nil), "stellarstation.api.v1.Telemetry")
	proto.RegisterType((*ListUpcomingAvailablePassesRequest)(nil), "stellarstation.api.v1.ListUpcomingAvailablePassesRequest")
	proto.RegisterType((*ListUpcomingAvailablePassesResponse)(nil), "stellarstation.api.v1.ListUpcomingAvailablePassesResponse")
	proto.RegisterType((*ReservePassRequest)(nil), "stellarstation.api.v1.ReservePassRequest")
	proto.RegisterType((*ReservePassResponse)(nil), "stellarstation.api.v1.ReservePassResponse")
	proto.RegisterType((*Pass)(nil), "stellarstation.api.v1.Pass")
	proto.RegisterType((*Plan)(nil), "stellarstation.api.v1.Plan")
	proto.RegisterEnum("stellarstation.api.v1.Framing", Framing_name, Framing_value)
	proto.RegisterEnum("stellarstation.api.v1.Plan_Status", Plan_Status_name, Plan_Status_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// StellarStationServiceClient is the client API for StellarStationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StellarStationServiceClient interface {
	// Lists upcoming passes for a satellite. Passes that can be scheduled for the satellite with an
	// Acquisition of Signal (AOS) within 14 days from now will be returned. This method does not
	// reserve passes in any way - it is possible for a pass that is returned by this method to be
	// unschedulable when actually trying to schedule because a conflict appeared during that time.
	//
	// If the satellite is not found or the client is not authorized for it, the request will return
	// a `NOT_FOUND` error.
	ListUpcomingAvailablePasses(ctx context.Context, in *ListUpcomingAvailablePassesRequest, opts ...grpc.CallOption) (*ListUpcomingAvailablePassesResponse, error)
	// Open a stream to a satellite. The returned stream is bi-directional - it can be used by the
	// client to send commands to the satellite and data received from the satellite will be returned
	// as it is made available. All telemetry received from the satellite on reserved passes from this
	// point on will be returned as soon as this method is called. If
	// `SatelliteStreamRequest.stream_id` is specified, any messages that have been buffered for the
	// stream will be returned as well.
	//
	// The stream can be left open for any amount of time and telemetry will be received as available
	// and returned. When the client is done with the stream, it should close it successfully. If the
	// stream is cancelled with an unexpected error at any point, telemetry received before the next
	// call to `OpenSatelliteStream` to resume the stream will be buffered up to 1 minute, and if no
	// call to `OpenSatelliteStream` is made with `stream_id` specified to resume the stream, it will
	// expire in 10 minutes and a call to `OpenSatelliteStream` with that `stream_id` will be closed
	// with a `ABORTED` error.
	//
	// If the satellite is not found or the client is not authorized for it, the stream will be closed
	// with a `NOT_FOUND` error.
	OpenSatelliteStream(ctx context.Context, opts ...grpc.CallOption) (StellarStationService_OpenSatelliteStreamClient, error)
	// Reserves a pass for later execution as a plan. The pass must be specified by a
	// `reservation_token` returned in another method like `ListUpcomingAvailablePasses` and its
	// `aos_time` must be at least one hour in the future.
	//
	// If the `reservation_token` is invalid, the request will return an `INVALID_ARGUMENT` error.
	//
	// If the requested pass cannot be scheduled due to a conflict with existing plans or other
	// scheduling constraints, the request will return a `FAILED_PRECONDITION` error. This includes
	// if the pass `aos_time` is less than one hour in the future.
	//
	// Note that the reservation_token may have become unreservable since it was fetched. If that's
	// the case, the call to `ReservePass` will fail with a 'FAILED_PRECONDITION' error and
	// `ListUpcomingAvailablePasses` should be called again to get a fresh list of reservable passes.
	// The pass must be scheduled at least one hour in advance of `aos_time` or it will be rejected.
	ReservePass(ctx context.Context, in *ReservePassRequest, opts ...grpc.CallOption) (*ReservePassResponse, error)
}

type stellarStationServiceClient struct {
	cc *grpc.ClientConn
}

func NewStellarStationServiceClient(cc *grpc.ClientConn) StellarStationServiceClient {
	return &stellarStationServiceClient{cc}
}

func (c *stellarStationServiceClient) ListUpcomingAvailablePasses(ctx context.Context, in *ListUpcomingAvailablePassesRequest, opts ...grpc.CallOption) (*ListUpcomingAvailablePassesResponse, error) {
	out := new(ListUpcomingAvailablePassesResponse)
	err := c.cc.Invoke(ctx, "/stellarstation.api.v1.StellarStationService/ListUpcomingAvailablePasses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stellarStationServiceClient) OpenSatelliteStream(ctx context.Context, opts ...grpc.CallOption) (StellarStationService_OpenSatelliteStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StellarStationService_serviceDesc.Streams[0], "/stellarstation.api.v1.StellarStationService/OpenSatelliteStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &stellarStationServiceOpenSatelliteStreamClient{stream}
	return x, nil
}

type StellarStationService_OpenSatelliteStreamClient interface {
	Send(*SatelliteStreamRequest) error
	Recv() (*SatelliteStreamResponse, error)
	grpc.ClientStream
}

type stellarStationServiceOpenSatelliteStreamClient struct {
	grpc.ClientStream
}

func (x *stellarStationServiceOpenSatelliteStreamClient) Send(m *SatelliteStreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *stellarStationServiceOpenSatelliteStreamClient) Recv() (*SatelliteStreamResponse, error) {
	m := new(SatelliteStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *stellarStationServiceClient) ReservePass(ctx context.Context, in *ReservePassRequest, opts ...grpc.CallOption) (*ReservePassResponse, error) {
	out := new(ReservePassResponse)
	err := c.cc.Invoke(ctx, "/stellarstation.api.v1.StellarStationService/ReservePass", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StellarStationServiceServer is the server API for StellarStationService service.
type StellarStationServiceServer interface {
	// Lists upcoming passes for a satellite. Passes that can be scheduled for the satellite with an
	// Acquisition of Signal (AOS) within 14 days from now will be returned. This method does not
	// reserve passes in any way - it is possible for a pass that is returned by this method to be
	// unschedulable when actually trying to schedule because a conflict appeared during that time.
	//
	// If the satellite is not found or the client is not authorized for it, the request will return
	// a `NOT_FOUND` error.
	ListUpcomingAvailablePasses(context.Context, *ListUpcomingAvailablePassesRequest) (*ListUpcomingAvailablePassesResponse, error)
	// Open a stream to a satellite. The returned stream is bi-directional - it can be used by the
	// client to send commands to the satellite and data received from the satellite will be returned
	// as it is made available. All telemetry received from the satellite on reserved passes from this
	// point on will be returned as soon as this method is called. If
	// `SatelliteStreamRequest.stream_id` is specified, any messages that have been buffered for the
	// stream will be returned as well.
	//
	// The stream can be left open for any amount of time and telemetry will be received as available
	// and returned. When the client is done with the stream, it should close it successfully. If the
	// stream is cancelled with an unexpected error at any point, telemetry received before the next
	// call to `OpenSatelliteStream` to resume the stream will be buffered up to 1 minute, and if no
	// call to `OpenSatelliteStream` is made with `stream_id` specified to resume the stream, it will
	// expire in 10 minutes and a call to `OpenSatelliteStream` with that `stream_id` will be closed
	// with a `ABORTED` error.
	//
	// If the satellite is not found or the client is not authorized for it, the stream will be closed
	// with a `NOT_FOUND` error.
	OpenSatelliteStream(StellarStationService_OpenSatelliteStreamServer) error
	// Reserves a pass for later execution as a plan. The pass must be specified by a
	// `reservation_token` returned in another method like `ListUpcomingAvailablePasses` and its
	// `aos_time` must be at least one hour in the future.
	//
	// If the `reservation_token` is invalid, the request will return an `INVALID_ARGUMENT` error.
	//
	// If the requested pass cannot be scheduled due to a conflict with existing plans or other
	// scheduling constraints, the request will return a `FAILED_PRECONDITION` error. This includes
	// if the pass `aos_time` is less than one hour in the future.
	//
	// Note that the reservation_token may have become unreservable since it was fetched. If that's
	// the case, the call to `ReservePass` will fail with a 'FAILED_PRECONDITION' error and
	// `ListUpcomingAvailablePasses` should be called again to get a fresh list of reservable passes.
	// The pass must be scheduled at least one hour in advance of `aos_time` or it will be rejected.
	ReservePass(context.Context, *ReservePassRequest) (*ReservePassResponse, error)
}

func RegisterStellarStationServiceServer(s *grpc.Server, srv StellarStationServiceServer) {
	s.RegisterService(&_StellarStationService_serviceDesc, srv)
}

func _StellarStationService_ListUpcomingAvailablePasses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUpcomingAvailablePassesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StellarStationServiceServer).ListUpcomingAvailablePasses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stellarstation.api.v1.StellarStationService/ListUpcomingAvailablePasses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StellarStationServiceServer).ListUpcomingAvailablePasses(ctx, req.(*ListUpcomingAvailablePassesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StellarStationService_OpenSatelliteStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StellarStationServiceServer).OpenSatelliteStream(&stellarStationServiceOpenSatelliteStreamServer{stream})
}

type StellarStationService_OpenSatelliteStreamServer interface {
	Send(*SatelliteStreamResponse) error
	Recv() (*SatelliteStreamRequest, error)
	grpc.ServerStream
}

type stellarStationServiceOpenSatelliteStreamServer struct {
	grpc.ServerStream
}

func (x *stellarStationServiceOpenSatelliteStreamServer) Send(m *SatelliteStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *stellarStationServiceOpenSatelliteStreamServer) Recv() (*SatelliteStreamRequest, error) {
	m := new(SatelliteStreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _StellarStationService_ReservePass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReservePassRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StellarStationServiceServer).ReservePass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stellarstation.api.v1.StellarStationService/ReservePass",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StellarStationServiceServer).ReservePass(ctx, req.(*ReservePassRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _StellarStationService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "stellarstation.api.v1.StellarStationService",
	HandlerType: (*StellarStationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListUpcomingAvailablePasses",
			Handler:    _StellarStationService_ListUpcomingAvailablePasses_Handler,
		},
		{
			MethodName: "ReservePass",
			Handler:    _StellarStationService_ReservePass_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "OpenSatelliteStream",
			Handler:       _StellarStationService_OpenSatelliteStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "stellarstation/api/v1/stellarstation.proto",
}

func init() {
	proto.RegisterFile("stellarstation/api/v1/stellarstation.proto", fileDescriptor_stellarstation_68cc2fa00127c403)
}

var fileDescriptor_stellarstation_68cc2fa00127c403 = []byte{
	// 1115 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x97, 0xdd, 0x52, 0xdb, 0x46,
	0x14, 0xc7, 0x91, 0x6d, 0xfc, 0x71, 0xec, 0xa6, 0xee, 0x52, 0x82, 0x62, 0x98, 0xc6, 0x51, 0x6f,
	0x5c, 0x3a, 0xb1, 0x1b, 0x67, 0xd2, 0x21, 0xe9, 0xb4, 0x1d, 0x63, 0x04, 0x78, 0x86, 0x50, 0x22,
	0x99, 0x4c, 0x26, 0x37, 0x9a, 0x45, 0x5a, 0x1b, 0x4d, 0x24, 0xad, 0xab, 0x5d, 0xbb, 0x90, 0xe9,
	0x33, 0xf4, 0xaa, 0x8f, 0xd1, 0xbb, 0xbe, 0x47, 0xaf, 0x7b, 0xd9, 0x47, 0xe9, 0xec, 0x4a, 0x32,
	0xd8, 0x20, 0x43, 0x48, 0x7b, 0x67, 0x9d, 0x73, 0x7e, 0x67, 0xcf, 0x9e, 0xfd, 0x1f, 0xad, 0x0c,
	0x9b, 0x8c, 0x13, 0xcf, 0xc3, 0x21, 0xe3, 0x98, 0xbb, 0x34, 0x68, 0xe1, 0x91, 0xdb, 0x9a, 0x3c,
	0x69, 0xcd, 0x5a, 0x9b, 0xa3, 0x90, 0x72, 0x8a, 0x56, 0xe7, 0xac, 0x78, 0xe4, 0x36, 0x27, 0x4f,
	0x6a, 0x0f, 0x87, 0x94, 0x0e, 0x3d, 0xd2, 0x92, 0x41, 0x27, 0xe3, 0x41, 0x8b, 0xbb, 0x3e, 0x61,
	0x1c, 0xfb, 0xa3, 0x88, 0xd3, 0xfe, 0xc8, 0xc0, 0x7d, 0x13, 0x0b, 0xd6, 0xe5, 0xc4, 0xe4, 0x21,
	0xc1, 0xbe, 0x41, 0x7e, 0x1e, 0x13, 0xc6, 0xd1, 0x23, 0xa8, 0xb0, 0xc4, 0x63, 0xb9, 0x8e, 0xaa,
	0xd4, 0x95, 0x46, 0xc9, 0x28, 0x4f, 0x6d, 0x3d, 0x07, 0xad, 0x43, 0x89, 0x49, 0x46, 0xf8, 0x33,
	0xd2, 0x5f, 0x8c, 0x0c, 0x3d, 0x07, 0xfd, 0x0a, 0x0f, 0x19, 0x09, 0x1c, 0xeb, 0x22, 0x89, 0x4d,
	0x7d, 0x1f, 0x07, 0x0e, 0xb3, 0xc2, 0x68, 0x09, 0x35, 0x5b, 0x57, 0x1a, 0xe5, 0xf6, 0xd3, 0xe6,
	0xb5, 0xc5, 0x37, 0x4d, 0x12, 0x38, 0xd3, 0xda, 0xba, 0x31, 0x1b, 0x57, 0xb7, 0xbf, 0x64, 0x6c,
	0xb0, 0x05, 0x7e, 0xd4, 0x83, 0x2a, 0xb6, 0x6d, 0x32, 0xe2, 0xc4, 0xb1, 0x06, 0x21, 0xf6, 0xdd,
	0x60, 0xa8, 0xe6, 0xea, 0xd9, 0xc6, 0xbd, 0xf6, 0x17, 0x29, 0xcb, 0xed, 0x46, 0x51, 0xc6, 0xa7,
	0x09, 0x17, 0x1b, 0xb6, 0x4b, 0x50, 0x88, 0xb3, 0x6a, 0x5b, 0xb0, 0xb1, 0xa8, 0x2a, 0xa4, 0x42,
	0x21, 0xde, 0xa4, 0x9a, 0xa9, 0x67, 0x1b, 0x15, 0x23, 0x79, 0xd4, 0xfe, 0x54, 0x60, 0xed, 0x4a,
	0xa3, 0xd9, 0x88, 0x06, 0x8c, 0xcc, 0xb6, 0x51, 0x99, 0x6b, 0x23, 0x85, 0x5a, 0x48, 0x6c, 0xe2,
	0x4e, 0x88, 0xc5, 0x89, 0x47, 0x7c, 0xc2, 0xc3, 0x73, 0x2b, 0x8c, 0x51, 0xd9, 0xf4, 0x72, 0xbb,
	0x95, 0xb2, 0x25, 0x23, 0x02, 0xfb, 0x09, 0x97, 0xac, 0xb8, 0xbf, 0x64, 0xa8, 0x61, 0x8a, 0x6f,
	0x1b, 0xa0, 0x98, 0xfc, 0xd6, 0xde, 0x82, 0x9a, 0x96, 0x03, 0xfd, 0x00, 0xa5, 0x69, 0x41, 0xb2,
	0xea, 0x72, 0xbb, 0x9e, 0x52, 0xc7, 0x05, 0x7c, 0x81, 0x68, 0x7f, 0x67, 0xa0, 0x34, 0x75, 0xa0,
	0x2d, 0x28, 0x24, 0xc7, 0x24, 0x72, 0xdd, 0x7c, 0x4c, 0x49, 0x38, 0x42, 0x90, 0x73, 0x30, 0xc7,
	0xb2, 0x15, 0x15, 0x43, 0xfe, 0x46, 0x6d, 0x58, 0x75, 0xe8, 0x2f, 0x81, 0xe7, 0x06, 0xef, 0xac,
	0x81, 0x54, 0x5b, 0x60, 0x9f, 0x5b, 0xa7, 0xef, 0xa5, 0xe2, 0x72, 0xc6, 0x4a, 0xe2, 0xdc, 0x4d,
	0x7c, 0xfb, 0xef, 0x91, 0x09, 0xaa, 0x98, 0x0e, 0x6b, 0xe0, 0x86, 0x8c, 0x5b, 0x27, 0xe7, 0x9c,
	0x58, 0x71, 0x8f, 0x1c, 0x35, 0x27, 0xb7, 0x57, 0x6b, 0x46, 0xe3, 0xd4, 0x4c, 0xc6, 0xa9, 0xd9,
	0x4f, 0xc6, 0xc9, 0x58, 0x15, 0xec, 0xae, 0x40, 0xb7, 0xcf, 0x39, 0x89, 0x9b, 0xe6, 0xa0, 0x57,
	0xb0, 0x26, 0x93, 0x7a, 0xf8, 0x4a, 0xce, 0xe5, 0x1b, 0x73, 0x7e, 0x2e, 0xd0, 0x03, 0x3c, 0x97,
	0xf2, 0x11, 0x54, 0xc4, 0xd6, 0x89, 0x75, 0x4a, 0xb0, 0x43, 0x42, 0x35, 0x2f, 0xf7, 0x5d, 0x96,
	0xb6, 0x7d, 0x69, 0xd2, 0xf6, 0x40, 0x3b, 0x70, 0x19, 0x3f, 0x1e, 0xd9, 0x54, 0xb4, 0xa8, 0x33,
	0xc1, 0xae, 0x87, 0x4f, 0x3c, 0x72, 0x84, 0x19, 0x23, 0xec, 0xf6, 0x03, 0xae, 0xbd, 0x86, 0x2f,
	0x17, 0x26, 0x8a, 0xa5, 0xd0, 0x82, 0xdc, 0x08, 0x33, 0xa6, 0x2a, 0xf5, 0x6c, 0xa3, 0xdc, 0x5e,
	0x4f, 0x39, 0x39, 0x01, 0x19, 0x32, 0x50, 0xeb, 0x00, 0x32, 0x08, 0x23, 0xe1, 0x44, 0x66, 0x4a,
	0x0a, 0xfa, 0x1a, 0x3e, 0x0b, 0xa5, 0x55, 0x62, 0x16, 0xa7, 0xef, 0x48, 0x10, 0x57, 0x55, 0xbd,
	0xe4, 0xe8, 0x0b, 0xbb, 0xb6, 0x0b, 0x2b, 0x33, 0x29, 0x2e, 0x95, 0xe2, 0xe1, 0x20, 0x16, 0x64,
	0x6a, 0x29, 0x1e, 0x0e, 0x0c, 0x19, 0xa8, 0xfd, 0x95, 0x83, 0x9c, 0xc8, 0xf0, 0x41, 0xab, 0xa3,
	0x67, 0x50, 0xc4, 0x94, 0x59, 0xe2, 0x80, 0xe2, 0x19, 0x5c, 0x74, 0x90, 0x05, 0x4c, 0x99, 0x78,
	0x12, 0x98, 0x97, 0x60, 0xd9, 0x9b, 0x31, 0x2f, 0xc6, 0xbe, 0x85, 0xb5, 0x61, 0x48, 0xc7, 0xe2,
	0x65, 0x1a, 0xed, 0xc3, 0xf2, 0x30, 0x77, 0xf9, 0xd8, 0x21, 0x52, 0x99, 0x8a, 0xb1, 0x1a, 0xb9,
	0xcd, 0xc8, 0x7b, 0x10, 0x3b, 0xd1, 0x16, 0xa8, 0xf3, 0x1c, 0x0d, 0x86, 0x11, 0xb8, 0x2c, 0xc1,
	0xfb, 0xb3, 0x60, 0xe2, 0x45, 0xdf, 0xc3, 0xfa, 0x1c, 0x69, 0xd3, 0x71, 0x20, 0x5e, 0x3d, 0x36,
	0x75, 0x88, 0xd4, 0x5c, 0xc9, 0x50, 0x67, 0xe0, 0x6e, 0x14, 0xd0, 0xa5, 0x0e, 0x11, 0xf3, 0xe7,
	0xe3, 0x33, 0x8b, 0x78, 0x24, 0xee, 0xa6, 0x43, 0x86, 0x21, 0x21, 0x4c, 0x2d, 0xc8, 0x55, 0x57,
	0x7c, 0x7c, 0xa6, 0x27, 0xbe, 0x9d, 0xc8, 0x85, 0xf6, 0x01, 0xcd, 0x32, 0xb2, 0x4b, 0xc5, 0x1b,
	0xbb, 0x54, 0xbd, 0x9c, 0x4c, 0xb6, 0xeb, 0x47, 0xd8, 0x98, 0x4e, 0xbf, 0x4d, 0x02, 0x4e, 0xc2,
	0xd9, 0x97, 0x40, 0x49, 0xbe, 0x04, 0x1e, 0x24, 0x31, 0x5d, 0x19, 0x72, 0xf9, 0x55, 0xf0, 0x1d,
	0xd4, 0xc6, 0xa3, 0x54, 0x1c, 0x24, 0xbe, 0x16, 0x45, 0x5c, 0x81, 0xb5, 0x7f, 0x96, 0x21, 0x27,
	0xf4, 0x85, 0xee, 0x41, 0x66, 0x3a, 0x55, 0x19, 0xd7, 0xb9, 0x32, 0x6f, 0x99, 0xab, 0x17, 0xea,
	0x0b, 0xc8, 0x8b, 0x7e, 0x8f, 0x99, 0x54, 0xc7, 0xbd, 0xb6, 0xb6, 0x40, 0xbf, 0x4d, 0x53, 0x46,
	0x1a, 0x31, 0x31, 0x23, 0xc9, 0xdc, 0xdd, 0x24, 0xb9, 0xfc, 0x9f, 0x48, 0x32, 0x7f, 0x57, 0x49,
	0x16, 0x3e, 0x46, 0x92, 0xc5, 0xbb, 0x4a, 0xb2, 0xf4, 0xa1, 0x92, 0x84, 0xff, 0x41, 0x92, 0xe5,
	0x8f, 0x93, 0x64, 0x65, 0xb1, 0x24, 0x0f, 0x21, 0x1f, 0x89, 0x05, 0x55, 0xa0, 0x68, 0xe8, 0xa6,
	0x6e, 0xbc, 0xd6, 0x77, 0xaa, 0x4b, 0xe8, 0x13, 0x28, 0xe9, 0x6f, 0xf4, 0xee, 0x71, 0xbf, 0x77,
	0xb8, 0x57, 0x55, 0xc4, 0xa3, 0x79, 0xdc, 0xed, 0xea, 0xfa, 0x8e, 0xbe, 0x53, 0xcd, 0x20, 0x80,
	0xfc, 0x6e, 0xa7, 0x77, 0xa0, 0xef, 0x54, 0xb3, 0x82, 0xeb, 0x76, 0x0e, 0xbb, 0xba, 0x78, 0xca,
	0x6d, 0x3e, 0x87, 0x42, 0x7c, 0x0d, 0x0b, 0x66, 0xbb, 0xd7, 0x37, 0xfb, 0x86, 0xde, 0x79, 0x59,
	0x5d, 0x42, 0x45, 0xc8, 0x75, 0xde, 0xb4, 0x9f, 0x55, 0x15, 0x94, 0x87, 0x4c, 0xef, 0x55, 0x35,
	0x23, 0x02, 0x7a, 0x2f, 0x3b, 0x7b, 0xba, 0x75, 0x74, 0xb8, 0x57, 0xcd, 0xb6, 0x7f, 0xcb, 0xc2,
	0xaa, 0x19, 0x69, 0x3a, 0x3e, 0x24, 0x93, 0x84, 0x13, 0xd7, 0x26, 0xe8, 0x77, 0x05, 0xd6, 0x17,
	0x5c, 0x36, 0xe8, 0x79, 0xca, 0x2c, 0xdc, 0x7c, 0xd3, 0xd5, 0x5e, 0xdc, 0x05, 0x8d, 0x2f, 0x94,
	0x33, 0x58, 0xf9, 0x69, 0x44, 0x82, 0xb9, 0x6f, 0x37, 0xf4, 0x38, 0xed, 0xa3, 0xf5, 0xda, 0x8f,
	0xe9, 0x5a, 0xf3, 0xb6, 0xe1, 0xd1, 0xaa, 0x0d, 0xe5, 0x1b, 0x05, 0x39, 0x50, 0xbe, 0x74, 0xc3,
	0xa1, 0xaf, 0x52, 0x3f, 0xf2, 0xe6, 0x2f, 0xd2, 0xda, 0xe6, 0x6d, 0x42, 0xe3, 0xcf, 0xbd, 0x01,
	0x3c, 0xb0, 0xa9, 0x7f, 0x3d, 0xb0, 0xbd, 0x62, 0xce, 0x98, 0x8f, 0x84, 0xd4, 0x8f, 0x94, 0xb7,
	0xed, 0xa1, 0xcb, 0x4f, 0xc7, 0x27, 0x4d, 0x9b, 0xfa, 0x2d, 0x37, 0x18, 0xd0, 0x18, 0x76, 0x03,
	0xbb, 0x35, 0xa4, 0x8f, 0xaf, 0xfd, 0xdb, 0x72, 0x92, 0x97, 0x73, 0xf2, 0xf4, 0xdf, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x9f, 0x8d, 0x7e, 0x03, 0xd6, 0x0c, 0x00, 0x00,
}
